```zig
/// lib.zig

//! libxev-http: High-performance async HTTP framework for Zig
//!
//! A modern, production-ready HTTP server built on libxev for maximum performance
//! and cross-platform compatibility.
//!
//! ## Features
//! - Async event-driven architecture using libxev
//! - High-performance routing with parameter extraction
//! - Middleware support for request/response processing
//! - Memory-safe HTTP parsing and response building
//! - Cross-platform compatibility (Linux, macOS, Windows)
//! - Production-ready security features

const std = @import("std");
const xev = @import("xev");
const net = std.net;
const log = std.log;
const security = @import("security.zig");
const middleware = @import("middleware.zig");

// Version information
pub const version = "1.0.0";
pub const version_major = 1;
pub const version_minor = 0;
pub const version_patch = 0;

// Re-export commonly used types
pub const Allocator = std.mem.Allocator;
pub const ArrayList = std.ArrayList;
pub const StringHashMap = std.StringHashMap;

// Re-export core modules
pub const HttpRequest = @import("request.zig").HttpRequest;
pub const HttpMethod = @import("request.zig").HttpMethod;
pub const HttpResponse = @import("response.zig").HttpResponse;
pub const StatusCode = @import("response.zig").StatusCode;
pub const Context = @import("context.zig").Context;
pub const Router = @import("router.zig").Router;
pub const Route = @import("router.zig").Route;
pub const HandlerFn = @import("router.zig").HandlerFn;

// Re-export utility modules
pub const Buffer = @import("buffer.zig").Buffer;
pub const BufferPool = @import("buffer.zig").BufferPool;
pub const BufferPoolStats = @import("buffer.zig").BufferPoolStats;
pub const HttpConfig = @import("config.zig").HttpConfig;
pub const AppConfig = @import("config.zig").AppConfig;
pub const loadConfig = @import("config.zig").loadConfig;

// Re-export security modules
pub const Security = @import("security.zig");
pub const SecurityLimits = @import("security.zig").SecurityLimits;
pub const SecurityResult = @import("security.zig").SecurityResult;
pub const ConnectionTiming = @import("security.zig").ConnectionTiming;

// Re-export middleware modules
pub const MiddlewareFn = middleware.MiddlewareFn;
pub const NextFn = middleware.NextFn;
pub const MiddlewareChain = middleware.MiddlewareChain;
pub const Middleware = middleware.Middleware;

// Built-in middleware
pub const loggingMiddleware = middleware.loggingMiddleware;
pub const corsMiddleware = middleware.corsMiddleware;
pub const securityHeadersMiddleware = middleware.securityHeadersMiddleware;
pub const requestIdMiddleware = middleware.requestIdMiddleware;
pub const rateLimitMiddleware = middleware.rateLimitMiddleware;
pub const basicAuthMiddleware = middleware.basicAuthMiddleware;
pub const jsonBodyParserMiddleware = middleware.jsonBodyParserMiddleware;
pub const errorHandlerMiddleware = middleware.errorHandlerMiddleware;
pub const compressionMiddleware = middleware.compressionMiddleware;

/// Client connection context for handling HTTP requests
const ClientConnection = struct {
    tcp: xev.TCP,
    server: *Server,
    allocator: Allocator,
    buffer: [8192]u8,
    read_completion: xev.Completion,
    write_completion: xev.Completion,
    close_completion: xev.Completion,
    read_len: usize,
    total_read: usize,
    response_data: ?[]u8,
    is_closing: bool,
    timing: security.ConnectionTiming,
    request_buffer: std.ArrayList(u8),

    fn init(tcp: xev.TCP, server: *Server, allocator: Allocator) ClientConnection {
        return ClientConnection{
            .tcp = tcp,
            .server = server,
            .allocator = allocator,
            .buffer = undefined,
            .read_len = 0,
            .total_read = 0,
            .read_completion = .{},
            .write_completion = .{},
            .close_completion = .{},
            .response_data = null,
            .is_closing = false,
            .timing = security.ConnectionTiming.init(),
            .request_buffer = std.ArrayList(u8).init(allocator),
        };
    }

    fn deinit(self: *ClientConnection) void {
        // Clean up response data
        if (self.response_data) |data| {
            self.allocator.free(data);
        }

        // Clean up request buffer
        self.request_buffer.deinit();

        // Destroy the connection object
        self.allocator.destroy(self);
    }

    fn close(self: *ClientConnection, loop: *xev.Loop) void {
        if (self.is_closing) return;
        self.is_closing = true;

        // Release connection pool slot immediately
        self.server.connection_pool.release();

        // Gracefully close TCP connection
        self.tcp.close(loop, &self.close_completion, ClientConnection, self, closeCallback);
    }

    /// Check if connection has timed out or has processing issues
    fn checkTimeouts(self: *ClientConnection) bool {
        const result = security.checkRequestTimeouts(&self.timing, self.server.config);

        switch (result) {
            .allowed => return false,
            .connection_timeout => {
                log.warn("‚è∞ Connection timeout exceeded", .{});
                return true;
            },
            .idle_timeout => {
                log.warn("‚è∞ Idle timeout exceeded", .{});
                return true;
            },
            .processing_timeout => {
                log.warn("‚è±Ô∏è Request processing timeout", .{});
                return true;
            },
            else => {
                log.warn("üö´ Request validation failed: {s}", .{security.getSecurityResultDescription(result)});
                return true;
            },
        }
    }
};

/// Server status information
pub const ServerStatus = struct {
    active_connections: u32,
    max_connections: u32,
    routes_count: u32,
};

/// Connection pool for managing active connections
const ConnectionPool = struct {
    active_connections: std.atomic.Value(u32),
    max_connections: u32,

    fn init(max_connections: u32) ConnectionPool {
        return ConnectionPool{
            .active_connections = std.atomic.Value(u32).init(0),
            .max_connections = max_connections,
        };
    }

    fn tryAcquire(self: *ConnectionPool) bool {
        while (true) {
            const current = self.active_connections.load(.acquire);
            if (current >= self.max_connections) {
                return false;
            }
            if (self.active_connections.cmpxchgWeak(current, current + 1, .acq_rel, .acquire) == null) {
                return true;
            }
        }
    }

    fn release(self: *ConnectionPool) void {
        _ = self.active_connections.fetchSub(1, .acq_rel);
    }

    fn getActiveCount(self: *ConnectionPool) u32 {
        return self.active_connections.load(.acquire);
    }
};

/// HTTP server built on libxev
pub const Server = struct {
    allocator: Allocator,
    host: []const u8,
    port: u16,
    router: *Router,
    connection_pool: ConnectionPool,
    config: HttpConfig,

    pub fn init(allocator: Allocator, host: []const u8, port: u16) !Server {
        return initWithConfig(allocator, host, port, HttpConfig{});
    }

    pub fn initWithMaxConnections(allocator: Allocator, host: []const u8, port: u16, max_connections: u32) !Server {
        var config = HttpConfig{};
        config.max_connections = max_connections;
        return initWithConfig(allocator, host, port, config);
    }

    pub fn initWithConfig(allocator: Allocator, host: []const u8, port: u16, config: HttpConfig) !Server {
        const router = try Router.init(allocator);

        return Server{
            .allocator = allocator,
            .host = host,
            .port = port,
            .router = router,
            .connection_pool = ConnectionPool.init(@intCast(config.max_connections)),
            .config = config,
        };
    }

    pub fn deinit(self: *Server) void {
        self.router.deinit();
        self.allocator.destroy(self.router);
    }

    /// Add a GET route
    pub fn get(self: *Server, path: []const u8, handler: HandlerFn) !*Route {
        return try self.router.get(path, handler);
    }

    /// Add a POST route
    pub fn post(self: *Server, path: []const u8, handler: HandlerFn) !*Route {
        return try self.router.post(path, handler);
    }

    /// Add a PUT route
    pub fn put(self: *Server, path: []const u8, handler: HandlerFn) !*Route {
        return try self.router.put(path, handler);
    }

    /// Add a DELETE route
    pub fn delete(self: *Server, path: []const u8, handler: HandlerFn) !*Route {
        return try self.router.delete(path, handler);
    }

    /// Add global middleware that applies to all routes
    pub fn use(self: *Server, name: []const u8, middleware_fn: MiddlewareFn) !void {
        return try self.router.use(name, middleware_fn);
    }

    /// Check if thread pool is enabled
    pub fn hasThreadPool(self: *Server) bool {
        return self.config.enable_thread_pool;
    }

    /// Get server status information
    pub fn getStatus(self: *Server) ServerStatus {
        return ServerStatus{
            .active_connections = self.connection_pool.getActiveCount(),
            .max_connections = self.connection_pool.max_connections,
            .routes_count = @intCast(self.router.routes.items.len),
        };
    }

    /// Start the HTTP server with complete HTTP processing
    pub fn listen(self: *Server) !void {
        log.info("üöÄ Starting libxev-http server on {s}:{}", .{ self.host, self.port });
        log.info("üéØ Routes registered: {}", .{self.router.routes.items.len});
        log.info("üîó Max connections: {}", .{self.connection_pool.max_connections});

        // Show registered routes
        for (self.router.routes.items) |route| {
            log.info("   üìç {any} {s}", .{ route.method, route.pattern });
        }

        // Initialize libxev thread pool if enabled
        var libxev_thread_pool: ?xev.ThreadPool = null;
        if (self.config.enable_thread_pool) {
            libxev_thread_pool = xev.ThreadPool.init(.{
                .max_threads = if (self.config.thread_pool_size == 0)
                    @max(1, @as(u32, @intCast(std.Thread.getCpuCount() catch 4)))
                else
                    self.config.thread_pool_size,
                .stack_size = self.config.thread_pool_stack_size,
            });
            log.info("üßµ libxev ThreadPool initialized with {} max threads", .{libxev_thread_pool.?.max_threads});
        }
        defer if (libxev_thread_pool) |*pool| pool.deinit();

        // Initialize libxev event loop with optional thread pool
        var loop = try xev.Loop.init(.{
            .thread_pool = if (libxev_thread_pool) |*pool| pool else null,
        });
        defer loop.deinit();

        // Create TCP server
        const address = try net.Address.parseIp(self.host, self.port);
        var tcp_server = try xev.TCP.init(address);

        // Bind and listen
        try tcp_server.bind(address);
        try tcp_server.listen(128);

        log.info("‚úÖ Server listening on http://{s}:{}", .{ self.host, self.port });
        log.info("üîÑ Server running... Press Ctrl+C to stop", .{});

        // Start accepting connections
        var accept_completion: xev.Completion = .{};
        tcp_server.accept(&loop, &accept_completion, Server, self, acceptCallback);

        // Run the event loop
        try loop.run(.until_done);
    }
};

/// Callback for closing connections
fn closeCallback(
    userdata: ?*ClientConnection,
    loop: *xev.Loop,
    completion: *xev.Completion,
    tcp: xev.TCP,
    result: xev.CloseError!void,
) xev.CallbackAction {
    _ = loop;
    _ = completion;
    _ = tcp;
    const client_conn = userdata.?;

    result catch |err| {
        log.warn("Connection close error (expected): {any}", .{err});
    };

    log.info("üîí Connection closed", .{});
    client_conn.deinit();
    return .disarm;
}

/// Callback for accepting new connections
fn acceptCallback(
    userdata: ?*Server,
    loop: *xev.Loop,
    completion: *xev.Completion,
    result: xev.AcceptError!xev.TCP,
) xev.CallbackAction {
    _ = completion;
    const server = userdata.?;

    const client_tcp = result catch |err| {
        log.err("Failed to accept connection: {any}", .{err});
        return .rearm;
    };

    // Check if connection pool is full
    if (!server.connection_pool.tryAcquire()) {
        log.warn("‚ö†Ô∏è  Connection pool full, rejecting connection. Active: {}", .{server.connection_pool.getActiveCount()});
        return .rearm;
    }

    log.info("üì• Accepted new connection (Active: {})", .{server.connection_pool.getActiveCount()});

    // Create client connection
    const client_conn = server.allocator.create(ClientConnection) catch |err| {
        log.err("Failed to allocate client connection: {any}", .{err});
        server.connection_pool.release();
        return .rearm;
    };

    client_conn.* = ClientConnection.init(client_tcp, server, server.allocator);

    // Start reading HTTP request
    // Use client_conn.read_completion
    client_tcp.read(loop, &client_conn.read_completion, .{ .slice = &client_conn.buffer }, ClientConnection, client_conn, readCallback);

    return .rearm;
}

/// Callback for reading HTTP request data
fn readCallback(
    userdata: ?*ClientConnection,
    loop: *xev.Loop,
    completion: *xev.Completion,
    tcp: xev.TCP,
    buffer: xev.ReadBuffer,
    result: xev.ReadError!usize,
) xev.CallbackAction {
    _ = completion;
    _ = tcp;
    _ = buffer;
    const client_conn = userdata.?;

    const bytes_read = result catch |err| {
        log.err("Failed to read from connection: {any}", .{err});
        client_conn.close(loop);
        return .disarm;
    };

    if (bytes_read == 0) {
        log.info("üì§ Connection closed by client", .{});
        client_conn.close(loop);
        return .disarm;
    }

    // Update timing information
    client_conn.timing.updateReadTime();
    client_conn.total_read += bytes_read;

    // Check for timeouts and slow attacks
    if (client_conn.checkTimeouts()) {
        log.warn("üö´ Closing connection due to timeout or slow attack", .{});
        client_conn.close(loop);
        return .disarm;
    }

    // Check for reasonable request size limits - allow for large bodies but prevent abuse
    const max_reasonable_request = client_conn.server.config.max_body_size + 64 * 1024; // body + 64KB for headers
    if (client_conn.total_read > max_reasonable_request) {
        log.warn("üö´ Request too large: {} bytes (limit: {} bytes)", .{ client_conn.total_read, max_reasonable_request });
        sendErrorResponse(client_conn, loop, .payload_too_large) catch {};
        return .disarm;
    }

    log.info("üì® Received {} bytes (total: {})", .{ bytes_read, client_conn.total_read });

    // Append data to request buffer
    client_conn.request_buffer.appendSlice(client_conn.buffer[0..bytes_read]) catch |err| {
        log.err("Failed to append to request buffer: {any}", .{err});
        sendErrorResponse(client_conn, loop, .internal_server_error) catch {};
        return .disarm;
    };

    // Check if we have complete headers
    if (!client_conn.timing.headers_complete) {
        if (std.mem.indexOf(u8, client_conn.request_buffer.items, "\r\n\r\n")) |_| {
            // Parse Content-Length if present
            const content_length = security.parseContentLength(client_conn.request_buffer.items);
            client_conn.timing.setHeadersComplete(content_length);
        }
    }

    // Update body length tracking
    if (client_conn.timing.headers_complete) {
        const header_end = std.mem.indexOf(u8, client_conn.request_buffer.items, "\r\n\r\n");
        const body_length = if (header_end) |end_pos|
            client_conn.request_buffer.items.len - (end_pos + 4)
        else
            0;
        client_conn.timing.updateBodyLength(body_length);
    }

    // Try to process the request if we have enough data
    const should_process = blk: {
        if (!client_conn.timing.headers_complete) {
            break :blk false; // Need complete headers
        }

        if (client_conn.timing.expected_body_length) |expected| {
            break :blk client_conn.timing.received_body_length >= expected; // Need complete body
        }

        break :blk true; // No body expected, headers are enough
    };

    if (should_process) {
        // Process the complete HTTP request
        processHttpRequestFromBuffer(client_conn, loop) catch |err| {
            log.err("Failed to process HTTP request: {any}", .{err});
            sendErrorResponse(client_conn, loop, .internal_server_error) catch {};
        };
        return .disarm;
    } else {
        // Continue reading more data
        client_conn.tcp.read(loop, &client_conn.read_completion, .{ .slice = &client_conn.buffer }, ClientConnection, client_conn, readCallback);
        return .disarm;
    }
}

/// Process HTTP request from accumulated buffer and send response
fn processHttpRequestFromBuffer(client_conn: *ClientConnection, loop: *xev.Loop) !void {
    const request_data = client_conn.request_buffer.items;

    // Parse HTTP request
    var request = HttpRequest.parseFromBuffer(client_conn.allocator, request_data, client_conn.server.config) catch |err| {
        log.err("Failed to parse HTTP request: {any}", .{err});
        try sendErrorResponse(client_conn, loop, .bad_request);
        return;
    };
    defer request.deinit();

    log.info("üìã Processing {any} {s}", .{ request.method, request.path });

    // Create HTTP response
    var response = HttpResponse.init(client_conn.allocator);
    defer response.deinit();

    // Create context
    var ctx = Context.init(client_conn.allocator, &request, &response);
    defer ctx.deinit();

    // Handle request with router
    client_conn.server.router.handleRequest(&ctx) catch |err| {
        log.err("Router error: {any}", .{err});
        switch (err) {
            error.NotFound => {
                ctx.status(.not_found);
                try ctx.json("{\"error\":\"Not Found\",\"message\":\"The requested resource was not found\"}");
            },
            error.InvalidMethod => {
                ctx.status(.method_not_allowed);
                try ctx.json("{\"error\":\"Method Not Allowed\",\"message\":\"The HTTP method is not supported\"}");
            },
            else => {
                ctx.status(.internal_server_error);
                try ctx.json("{\"error\":\"Internal Server Error\",\"message\":\"An unexpected error occurred\"}");
            },
        }
    };

    // Build and send response
    const response_data = try response.build();

    log.info("üì§ Sending {} bytes response", .{response_data.len});
    try sendResponse(client_conn, loop, response_data);
}

/// Process HTTP request and send response (legacy function for compatibility)
fn processHttpRequest(client_conn: *ClientConnection, loop: *xev.Loop) !void {
    // For legacy compatibility, copy buffer data to request_buffer and process
    try client_conn.request_buffer.appendSlice(client_conn.buffer[0..client_conn.read_len]);
    return processHttpRequestFromBuffer(client_conn, loop);
}

/// Send HTTP response to client
fn sendResponse(client_conn: *ClientConnection, loop: *xev.Loop, response_data: []u8) !void {
    // Use client_conn.write_completion
    // Store response_data in ClientConnection to keep it alive
    client_conn.response_data = response_data;
    client_conn.tcp.write(loop, &client_conn.write_completion, .{ .slice = response_data }, ClientConnection, client_conn, writeCallback);

    // Run one iteration to complete the write
}

/// Callback for writing response data
fn writeCallback(
    userdata: ?*ClientConnection,
    loop: *xev.Loop,
    completion: *xev.Completion,
    tcp: xev.TCP,
    buffer: xev.WriteBuffer,
    result: xev.WriteError!usize,
) xev.CallbackAction {
    _ = completion;
    _ = tcp;
    _ = buffer;
    const client_conn = userdata.?;

    const bytes_written = result catch |err| {
        log.err("Failed to write response: {any}", .{err});
        client_conn.close(loop);
        return .disarm;
    };

    log.info("‚úÖ Sent {} bytes response", .{bytes_written});

    // Close connection after sending response
    client_conn.close(loop);
    return .disarm;
}

/// Send error response to client
fn sendErrorResponse(client_conn: *ClientConnection, loop: *xev.Loop, status: StatusCode) !void {
    var response = HttpResponse.init(client_conn.allocator);
    defer response.deinit();

    response.status = status;
    try response.setHeader("Content-Type", "application/json");
    try response.setHeader("Connection", "close");

    const error_json = try std.fmt.allocPrint(client_conn.allocator, "{{\"error\":\"{s}\",\"code\":{}}}", .{ status.toString(), @intFromEnum(status) });
    defer client_conn.allocator.free(error_json);

    try response.setBody(error_json);

    const response_data = try response.build();

    try sendResponse(client_conn, loop, response_data);
}

/// Create a new HTTP server
pub fn createServer(allocator: Allocator, host: []const u8, port: u16) !Server {
    return try Server.init(allocator, host, port);
}

/// Create a new HTTP server with custom max connections
pub fn createServerWithMaxConnections(allocator: Allocator, host: []const u8, port: u16, max_connections: u32) !Server {
    return try Server.initWithMaxConnections(allocator, host, port, max_connections);
}

/// Create a new HTTP server with custom configuration
pub fn createServerWithConfig(allocator: Allocator, host: []const u8, port: u16, config: HttpConfig) !Server {
    return try Server.initWithConfig(allocator, host, port, config);
}

// Tests
test "library exports" {
    const testing = std.testing;
    try testing.expect(version_major == 1);
    try testing.expect(version_minor == 0);
    try testing.expect(version_patch == 0);
    try testing.expectEqualStrings("1.0.0", version);
}

test "server creation and routes" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var server = try createServer(allocator, "127.0.0.1", 8080);
    defer server.deinit();

    try testing.expectEqualStrings("127.0.0.1", server.host);
    try testing.expect(server.port == 8080);

    // Test adding routes
    const testHandler = struct {
        fn handler(ctx: *Context) !void {
            _ = ctx;
        }
    }.handler;

    _ = try server.get("/", testHandler);
    _ = try server.post("/api/users", testHandler);

    try testing.expect(server.router.routes.items.len == 2);
}

test "module integration" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Test request parsing
    const raw_request = "GET /hello HTTP/1.1\r\nHost: localhost\r\n\r\n";
    const config = HttpConfig{};
    var request = try HttpRequest.parseFromBuffer(allocator, raw_request, config);
    defer request.deinit();

    // Test response building
    var response = HttpResponse.init(allocator);
    defer response.deinit();

    // Test context
    var ctx = Context.init(allocator, &request, &response);
    defer ctx.deinit();

    try ctx.json("{\"message\":\"test\"}");

    try testing.expectEqualStrings("GET", request.method);
    try testing.expectEqualStrings("/hello", request.path);
    try testing.expect(response.body != null);
}

```

Excellent! Let's move from the "recipe book" (`build.zig`) to the "main kitchen" itself. This file, `lib.zig`, is the heart of our web server library. It's where all the core components are assembled and managed.

---

### Welcome, Class! Inside the Engine Room: `lib.zig`

Yesterday, we looked at the `build.zig` file, which was our recipe book for compiling the project. Today, we're stepping into the main factory, the engine room where all the work happens: `lib.zig`.

This file has two primary jobs:
1.  **It defines the main `Server` and how it handles connections.** This is the core logic.
2.  **It acts as the main "front door" or "lobby" for our entire library.** It gathers all the important pieces from other files (`request.zig`, `response.zig`, etc.) and presents them in one convenient place for the person using our library.

Let's start at the top.

---

### Part 1: The Library's "Lobby" (Imports & Re-exports)

```zig
//! libxev-http: High-performance async HTTP framework for Zig
//! ... (documentation comments)

const std = @import("std");
const xev = @import("xev");
// ... other imports

// Version information
pub const version = "1.0.0";
// ...

// Re-export commonly used types
pub const Allocator = std.mem.Allocator;
// ...

// Re-export core modules
pub const HttpRequest = @import("request.zig").HttpRequest;
pub const HttpResponse = @import("response.zig").HttpResponse;
// ... (many more re-exports)
```

The first thing you'll notice after the initial documentation comments (`//!`) is a huge block of `pub const ...` lines. This is a very important and friendly design pattern in Zig.

Think of our library as a large company building with many different departments on different floors (e.g., the `request.zig` file is the "Incoming Mail Department," `response.zig` is the "Outgoing Mail Department").

Instead of making a visitor (the programmer using our library) run around to all these different files to get what they need, we've created a **central lobby** right here in `lib.zig`.

These `pub const` lines are like a directory in the lobby. We're saying:
*   "Looking for `HttpRequest`? You don't have to know it's in `request.zig`. You can just get it right here from the main library."
*   "Need a `Router`? It's right here."
*   "Looking for some built-in `loggingMiddleware`? We've brought it out to the front for you."

This is called **re-exporting**. It makes our library much cleaner and easier to use. The user only needs to `@import` this one file to get access to all the most important tools.

---

### Part 2: The Core Components (Structs)

Now we get to the main machinery. There are three key data structures, or `struct`s, that work together. Let's use an analogy of a busy restaurant.

#### `ClientConnection`: The Waiter

```zig
const ClientConnection = struct {
    tcp: xev.TCP,
    server: *Server,
    allocator: Allocator,
    buffer: [8192]u8,
    // ... other fields
};
```
This struct represents **one single client** connected to our server. Think of this as a **waiter** assigned to a specific table.

*   `tcp: xev.TCP`: This is the direct phone line to the customer (the TCP connection).
*   `server: *Server`: A reference back to the "Restaurant Manager" so the waiter knows who they work for.
*   `allocator: Allocator`: The waiter's budget for things like taking notes or preparing the bill.
*   `buffer`: The waiter's notepad, where they write down the customer's order as it comes in.
*   `timing`: A stopwatch to make sure a customer doesn't take forever to order (this prevents certain types of attacks).
*   `init()` and `deinit()`: These functions are like the waiter setting up the table for a new customer and clearing it after they leave.

#### `ConnectionPool`: The Host/Hostess

```zig
const ConnectionPool = struct {
    active_connections: std.atomic.Value(u32),
    max_connections: u32,
};
```
This struct's job is to make sure our restaurant doesn't get overcrowded. It's the **host or hostess** at the front door.

*   `max_connections`: The fire code limit for our restaurant. We can't have more customers than this.
*   `active_connections`: The current number of customers in the restaurant. (It's `atomic` which is a special type that ensures this count is accurate even when many waiters try to update it at the exact same time).
*   `tryAcquire()`: This is like asking the hostess, "Is there a free table?" It returns `true` if yes, `false` if the restaurant is full.
*   `release()`: This is the waiter telling the hostess, "My table is free now!"

#### `Server`: The Restaurant Manager

```zig
pub const Server = struct {
    allocator: Allocator,
    host: []const u8,
    port: u16,
    router: *Router,
    connection_pool: ConnectionPool,
    config: HttpConfig,
};
```
This is the big boss, the **Restaurant Manager**. It holds everything together.

*   `host` and `port`: The restaurant's address.
*   `router`: The **menu**. This is the component that knows what to do for each request (e.g., if a customer asks for `/users`, the router knows to call the "get users" chef).
*   `connection_pool`: The manager's connection to the hostess at the front door.
*   `get()`, `post()`, `use()`: These are methods the owner uses to tell the manager to add new items to the menu (the router).
*   `listen()`: This is the most important function. It's the manager shouting, **"We're open for business!"** and starting the whole process.

---

### Part 3: The Asynchronous Magic (Callbacks)

This is the most important concept to understand. Our server is **asynchronous** or **event-driven**.

A *synchronous* restaurant would have the manager constantly running to the front door shouting "ANYONE THERE YET? ANYONE THERE YET?". This is very inefficient.

Our *asynchronous* restaurant works with a system of bells.
1.  The manager tells the front door: "Ring a bell when a customer arrives." (`tcp_server.accept`)
2.  The manager goes off and does other things.
3.  When a customer arrives, a bell rings, and a special function called a **callback** is automatically run.

Let's follow the lifecycle of one request:

#### Step 1: `acceptCallback`
*   **The Event:** A new customer walks in the door. The `accept` bell rings!
*   **The Action:** The `acceptCallback` function runs.
    *   It first asks the `connection_pool` (the hostess), "Do we have a free table?"
    *   If yes, it creates a new `ClientConnection` (assigns a new waiter to the table).
    *   It then tells the new waiter, "Ring a bell for me as soon as this customer starts speaking." (`client_tcp.read`).

#### Step 2: `readCallback`
*   **The Event:** The customer starts giving their order (sends HTTP request data). The `read` bell rings!
*   **The Action:** The `readCallback` function runs for that specific `ClientConnection` (waiter).
    *   It writes down what the customer said into its `buffer` (notepad).
    *   It checks, "Is this the full order, or are they still talking?" It looks for the special `\r\n\r\n` sequence that marks the end of the HTTP headers.
    *   If the order isn't complete, it just says, "Okay, keep listening."
    *   If the order *is* complete, it calls `processHttpRequestFromBuffer` to send the order to the kitchen.

#### Step 3: `processHttpRequestFromBuffer` (The Kitchen)
*   This isn't a callback, but it's the next step.
*   It takes the raw text from the waiter's notepad.
*   It parses it into a structured `HttpRequest` object.
*   It looks at the request path (e.g., `/users`) and gives it to the `router` (the menu).
*   The router finds the correct chef (`HandlerFn`) to handle this specific dish.
*   The chef prepares the meal and puts it into an `HttpResponse` object.
*   Finally, it tells a waiter to deliver the food by calling `sendResponse`.

#### Step 4: `writeCallback`
*   **The Event:** The waiter has successfully delivered the food to the customer. The `write` bell rings!
*   **The Action:** The `writeCallback` function runs.
    *   It logs that the response was sent successfully.
    *   Since the transaction is complete, it tells the customer's connection to close (`client_conn.close`).

#### Step 5: `closeCallback`
*   **The Event:** The connection has been fully closed. The `close` bell rings!
*   **The Action:** The `closeCallback` function runs.
    *   It cleans up everything associated with that waiter and table (`client_conn.deinit()`).
    *   Crucially, the waiter also tells the hostess their table is now free (`self.server.connection_pool.release()`, which happens inside the `close` function).

---

### Part 4: The Self-Checks (Tests)

```zig
test "library exports" { ... }
test "server creation and routes" { ... }
test "module integration" { ... }
```
At the very bottom of the file, you see `test` blocks. These are built-in checks to make sure our kitchen is working correctly.
*   `test "server creation and routes"` is like checking that the manager can correctly add items to the menu.
*   `test "module integration"` is a quick check to ensure the whole process‚Äîfrom taking an order to preparing a response‚Äîworks on a small scale.

### Conclusion

This `lib.zig` file is the heart of the server. It uses a series of structs to manage the server's state and an asynchronous, event-driven model with callbacks to handle many connections efficiently without getting stuck waiting for any single one. It's like a well-run restaurant where the staff doesn't stand around waiting, but instead responds instantly when a bell rings, signaling that their attention is needed.


Â•ΩÁöÑÔºåÊàë‰ª¨Êù•ÊâÆÊºîËÄÅÂ∏àÂíåÂ≠¶ÁîüÔºå‰∏ÄËµ∑Ê∑±ÂÖ•Á†îÁ©∂Ëøô‰∏™ `lib.zig` Êñá‰ª∂„ÄÇËøô‰∏™Êñá‰ª∂ÊòØÊï¥‰∏™ Web Ê°ÜÊû∂ÁöÑÂøÉËÑèÔºåÊâÄÊúâÁöÑÊ†∏ÂøÉÈÄªËæëÈÉΩÂú®ËøôÈáå„ÄÇ

---

### ÂêÑ‰ΩçÂêåÂ≠¶ÔºåÊ¨¢ËøéÊù•Âà∞ÂºïÊìéÂÆ§Ôºö`lib.zig` Êñá‰ª∂ËØ¶Ëß£

Êò®Â§©Êàë‰ª¨Â≠¶‰π†‰∫Ü `build.zig`ÔºåÈÇ£ÊòØÊàë‰ª¨È°πÁõÆÁöÑ‚ÄúËèúË∞±‚Äù„ÄÇ‰ªäÂ§©ÔºåÊàë‰ª¨Ë¶ÅËµ∞ËøõÁúüÊ≠£ÁöÑ‚ÄúÂé®Êàø‚ÄùÊàñËÄÖËØ¥‚ÄúÂºïÊìéÂÆ§‚Äù‚Äî‚Äî`lib.zig` Êñá‰ª∂„ÄÇ

Ëøô‰∏™Êñá‰ª∂‰∏ªË¶ÅÊúâ‰∏§‰∏™ËÅåË¥£Ôºö

1.  **ÂÆö‰πâÊ†∏ÂøÉÁöÑ `Server`ÔºàÊúçÂä°Âô®Ôºâ‰ª•ÂèäÂÆÉÂ¶Ç‰ΩïÂ§ÑÁêÜÁΩëÁªúËøûÊé•„ÄÇ** ËøôÊòØÊúÄÂÖ≥ÈîÆÁöÑËøêË°åÈÄªËæë„ÄÇ
2.  **ÂÖÖÂΩìÊï¥‰∏™Â∫ìÁöÑ‚ÄúÂ§ßÈó®‚ÄùÊàñ‚ÄúÂâçÂè∞‚Äù„ÄÇ** ÂÆÉÊääÂÖ∂‰ªñÊñá‰ª∂ÔºàÂ¶Ç `request.zig`, `response.zig`Ôºâ‰∏≠ÊúÄÈáçË¶ÅÁöÑÈÉ®ÂàÜÈõÜ‰∏≠Ëµ∑Êù•ÔºåÊñπ‰æø‰ΩøÁî®Ëøô‰∏™Â∫ìÁöÑÁ®ãÂ∫èÂëòË∞ÉÁî®„ÄÇ

Êàë‰ª¨‰ªéÂ§¥ÂºÄÂßãÁúã„ÄÇ

---

### Á¨¨‰∏ÄÈÉ®ÂàÜÔºöÂ∫ìÁöÑ‚ÄúÂâçÂè∞Â§ßÂéÖ‚ÄùÔºàÂØºÂÖ•‰∏éÈáçÂØºÂá∫Ôºâ

```zig
//! libxev-http: High-performance async HTTP framework for Zig
//! ... (Ëøô‰∫õÊòØÊñáÊ°£Ê≥®Èáä)

const std = @import("std");
const xev = @import("xev");
// ... ÂÖ∂‰ªñÂØºÂÖ•

// Version information
pub const version = "1.0.0";
// ...

// Re-export commonly used types (ÈáçÂØºÂá∫Â∏∏Áî®Á±ªÂûã)
pub const Allocator = std.mem.Allocator;
// ...

// Re-export core modules (ÈáçÂØºÂá∫Ê†∏ÂøÉÊ®°Âùó)
pub const HttpRequest = @import("request.zig").HttpRequest;
pub const HttpResponse = @import("response.zig").HttpResponse;
// ... (ÂêéÈù¢ËøòÊúâÂæàÂ§öÁ±ª‰ººÁöÑË°å)
```

Âú®Êñá‰ª∂ÁöÑÂºÄÂ§¥Ôºå‰Ω†‰ºöÁúãÂà∞‰∏ÄÂ§ßÁâá `pub const ...`„ÄÇËøôÊòØ‰∏Ä‰∏™Âú® Zig ‰∏≠ÈùûÂ∏∏ÂèãÂ•Ω‰∏îÈáçË¶ÅÁöÑËÆæËÆ°Ê®°ÂºèÔºåÊàë‰ª¨Áß∞‰πã‰∏∫ **‚ÄúÈáçÂØºÂá∫‚ÄùÔºàRe-exportingÔºâ**„ÄÇ

ÊÉ≥Ë±°‰∏Ä‰∏ãÊàë‰ª¨ÁöÑÂ∫ìÊòØ‰∏Ä‰∏™ÊúâÂ§öÂ±ÇÂ§öÈÉ®Èó®ÁöÑÂ§ßÂÖ¨Âè∏ÔºàÊØîÂ¶Ç `request.zig` ÊòØ‚ÄúÊî∂ÂèëÂÆ§‚ÄùÔºå`response.zig` ÊòØ‚ÄúÂ§ñËÅîÈÉ®‚ÄùÔºâ„ÄÇ

Êàë‰ª¨‰∏çÂ∏åÊúõ‰∏Ä‰∏™ËÆøÂÆ¢Ôºà‰πüÂ∞±ÊòØ‰ΩøÁî®Êàë‰ª¨Â∫ìÁöÑÁ®ãÂ∫èÂëòÔºâ‰∏∫‰∫ÜÊâæ‰∏çÂêåÁöÑÂ∑•ÂÖ∑ËÄåË∑ëÈÅçÊâÄÊúâÈÉ®Èó®„ÄÇÊâÄ‰ª•ÔºåÊàë‰ª¨Âú®Ëøô‰∏™ `lib.zig` Êñá‰ª∂ÈáåÂª∫Á´ã‰∫Ü‰∏Ä‰∏™ **‚Äú‰∏≠Â§ÆÂâçÂè∞‚Äù**„ÄÇ

Ëøô‰∫õ `pub const` Ë°åÂ∞±ÂÉèÊòØÂâçÂè∞ÁöÑÊåáÁ§∫ÁâåÔºö
*   ‚ÄúÊÉ≥Êâæ `HttpRequest` ÂêóÔºü‰Ω†‰∏çÁî®Âéª `request.zig` Êñá‰ª∂ÈáåÊâæÔºåÁõ¥Êé•‰ªéÊàëËøôÈáåÔºà`lib.zig`ÔºâÊãøÂ∞±Ë°å„ÄÇ‚Äù
*   ‚ÄúÈúÄË¶Å `Router` ÂêóÔºüÁªô‰Ω†ÔºåÂú®ËøôÈáå„ÄÇ‚Äù

ËøôÊ†∑ÂÅöËÆ©Êàë‰ª¨ÁöÑÂ∫ìÂØπ‰ΩøÁî®ËÄÖÊù•ËØ¥ÈùûÂ∏∏Âπ≤ÂáÄ„ÄÅÊñπ‰æø„ÄÇÁî®Êà∑Âè™ÈúÄË¶Å `@import` Ëøô‰∏Ä‰∏™ `lib.zig` Êñá‰ª∂ÔºåÂ∞±ËÉΩËé∑ÂæóÊâÄÊúâÊúÄÊ†∏ÂøÉÁöÑÂ∑•ÂÖ∑„ÄÇ

---

### Á¨¨‰∫åÈÉ®ÂàÜÔºöÊ†∏ÂøÉÁªÑ‰ª∂ÔºàStruct ÁªìÊûÑ‰ΩìÔºâ

Áé∞Âú®Êàë‰ª¨Êù•ÁúãÁúãÈ©±Âä®ÊúçÂä°Âô®ËøêËΩ¨ÁöÑÊ†∏ÂøÉÊú∫Ê¢∞„ÄÇËøôÈáåÊúâ‰∏â‰∏™ÂÖ≥ÈîÆÁöÑÁªìÊûÑ‰ΩìÔºåÊàë‰ª¨ÂèØ‰ª•Áî®‰∏Ä‰∏™**ÁπÅÂøôÁöÑÈ§êÂéÖ**Êù•ÊØîÂñªÂÆÉ‰ª¨„ÄÇ

#### 1. `ClientConnection`ÔºöÊúçÂä°Âëò

```zig
const ClientConnection = struct {
    tcp: xev.TCP,
    server: *Server,
    allocator: Allocator,
    buffer: [8192]u8,
    // ... ÂÖ∂‰ªñÂ≠óÊÆµ
};
```

Ëøô‰∏™ÁªìÊûÑ‰Ωì‰ª£Ë°®**‰∏Ä‰∏™ËøûÊé•Âà∞ÊúçÂä°Âô®ÁöÑÁã¨Á´ãÂÆ¢Êà∑Á´Ø**„ÄÇ‰Ω†ÂèØ‰ª•ÊääÂÆÉÊÉ≥Ë±°Êàê‰∏Ä‰∏™**Ë¢´ÊåáÊ¥æÂà∞ÁâπÂÆöÈ§êÊ°åÁöÑ‚ÄúÊúçÂä°Âëò‚Äù**„ÄÇ

*   `tcp: xev.TCP`: ËøôÊòØ‰∏éÈ°æÂÆ¢ÁöÑ**Áõ¥Êé•ÁîµËØùÁ∫ø**ÔºàTCP ËøûÊé•Ôºâ„ÄÇ
*   `server: *Server`: ÊåáÂêë‚ÄúÈ§êÂéÖÁªèÁêÜ‚ÄùÔºåËøôÊ†∑ÊúçÂä°ÂëòÊâçÁü•ÈÅì‰∏∫Ë∞ÅÂ∑•‰Ωú„ÄÇ
*   `allocator: Allocator`: ÊúçÂä°ÂëòÁöÑ‚ÄúÁªèË¥π‚ÄùÔºåÁî®Êù•ËÆ∞ÂΩïÁÇπÂçï„ÄÅÂáÜÂ§áË¥¶ÂçïÁ≠âÈúÄË¶ÅÂÜÖÂ≠òÁöÑÊìç‰Ωú„ÄÇ
*   `buffer`: ÊúçÂä°ÂëòÁöÑ**ÁÇπÈ§êÊú¨**ÔºåÁî®Êù•ËÆ∞ÂΩïÈ°æÂÆ¢ËØ¥ÁöÑÊØè‰∏ÄÂè•ËØùÔºàËØ∑Ê±ÇÊï∞ÊçÆÔºâ„ÄÇ
*   `timing`: ‰∏Ä‰∏™ÁßíË°®ÔºåÁ°Æ‰øùÈ°æÂÆ¢‰∏ç‰ºöÁÇπ‰∏Ä‰∏™ËèúÁÇπÂçäÂ§©ÔºàËøôÂèØ‰ª•Èò≤Ê≠¢ÊÖ¢ÈÄüÊîªÂáªÔºâ„ÄÇ

#### 2. `ConnectionPool`ÔºöÈ§êÂéÖÈ¢Ü‰ΩçÂëò

```zig
const ConnectionPool = struct {
    active_connections: std.atomic.Value(u32),
    max_connections: u32,
};
```

Ëøô‰∏™ÁªìÊûÑ‰ΩìÁöÑÂîØ‰∏ÄÂ∑•‰ΩúÂ∞±ÊòØ**Á°Æ‰øùÈ§êÂéÖ‰∏ç‰ºö‰∫∫Êª°‰∏∫ÊÇ£**„ÄÇÂÆÉÂ∞±ÂÉèÊòØÁ´ôÂú®Èó®Âè£ÁöÑ**‚ÄúÈ¢Ü‰ΩçÂëò‚Äù**„ÄÇ

*   `max_connections`: È§êÂéÖÁöÑÊ∂àÈò≤ËßÑÂÆö‰∫∫Êï∞‰∏äÈôê„ÄÇ
*   `active_connections`: ÂΩìÂâçÂú®È§êÂéÖÈáåÁöÑÂÆ¢‰∫∫Êï∞Èáè„ÄÇÂÆÉÊòØ‰∏Ä‰∏™ `atomic`ÔºàÂéüÂ≠êÔºâÁ±ªÂûãÔºåÁ°Æ‰øùÂç≥‰ΩøÂæàÂ§öÊúçÂä°ÂëòÂêåÊó∂Êõ¥Êñ∞Ëøô‰∏™Êï∞Â≠óÔºåÂÆÉ‰πüÊÄªÊòØÂáÜÁ°ÆÁöÑ„ÄÇ
*   `tryAcquire()`: Áõ∏ÂΩì‰∫éÈóÆÈ¢Ü‰ΩçÂëòÔºö‚ÄúËøòÊúâÁ©∫Ê°åÂêóÔºü‚Äù Â¶ÇÊûúÊúâÔºåËøîÂõû `true`ÔºõÂ¶ÇÊûúÊª°‰∫ÜÔºåËøîÂõû `false`„ÄÇ
*   `release()`: ÊúçÂä°ÂëòÂëäËØâÈ¢Ü‰ΩçÂëòÔºö‚ÄúÊàëËøôÊ°åÂÆ¢‰∫∫Ëµ∞‰∫ÜÔºÅ‚Äù

#### 3. `Server`ÔºöÈ§êÂéÖÁªèÁêÜ

```zig
pub const Server = struct {
    // ...
    router: *Router,
    connection_pool: ConnectionPool,
    // ...
};
```
ËøôÊòØÊÄªÊåáÊå•‚Äî‚Äî**‚ÄúÈ§êÂéÖÁªèÁêÜ‚Äù**„ÄÇÂÆÉÊääÊâÄÊúâÈÉ®ÂàÜÁªÑÁªáÂú®‰∏ÄËµ∑„ÄÇ

*   `router`: È§êÂéÖÁöÑ**ËèúÂçï**„ÄÇÂÆÉÁü•ÈÅìÊØè‰∏™ËØ∑Ê±ÇËØ•Â¶Ç‰ΩïÂ§ÑÁêÜÔºà‰æãÂ¶ÇÔºåÈ°æÂÆ¢ÁÇπ `/users`ÔºåËèúÂçïÁü•ÈÅìËØ•ÊâæÂì™‰∏™Âé®Â∏àÔºâ„ÄÇ
*   `connection_pool`: ÁªèÁêÜÂíåÈó®Âè£È¢Ü‰ΩçÂëòÁöÑËÅîÁ≥ªÊñπÂºè„ÄÇ
*   `listen()`: ËøôÊòØÊúÄÈáçË¶ÅÁöÑÊñπÊ≥ï„ÄÇÂÆÉÁõ∏ÂΩì‰∫éÁªèÁêÜÂ§ßÂñä‰∏ÄÂ£∞Ôºö**‚ÄúÂºÄÈó®Ëê•‰∏öÔºÅ‚Äù**ÔºåÁÑ∂ÂêéÊï¥‰∏™È§êÂéÖÂ∞±ÂºÄÂßãËøê‰Ωú‰∫Ü„ÄÇ

---

### Á¨¨‰∏âÈÉ®ÂàÜÔºöÂºÇÊ≠•ÁöÑÈ≠îÊ≥ïÔºàÂõûË∞ÉÂáΩÊï∞‰∏é xevÔºâ

ËøôÊòØÊúÄÊ†∏ÂøÉ„ÄÅ‰πüÊúÄÈúÄË¶ÅÁêÜËß£ÁöÑÈÉ®ÂàÜ„ÄÇÊàë‰ª¨ÁöÑÊúçÂä°Âô®ÊòØ**ÂºÇÊ≠•ÁöÑÔºàasynchronousÔºâ**ÔºåÊàñËÄÖÂè´**‰∫ã‰ª∂È©±Âä®ÁöÑÔºàevent-drivenÔºâ**„ÄÇ

‰∏Ä‰∏™**ÂêåÊ≠•**ÁöÑÈ§êÂéÖÁªèÁêÜ‰ºö‰∏çÂÅúÂú∞Ë∑ëÂà∞Èó®Âè£ÂñäÔºö‚ÄúÊù•ÂÆ¢‰∫∫‰∫ÜÂêóÔºüÊù•ÂÆ¢‰∫∫‰∫ÜÂêóÔºü‚Äù ËøôÈùûÂ∏∏‰ΩéÊïà„ÄÇ

Êàë‰ª¨ÁöÑ**ÂºÇÊ≠•**È§êÂéÖÁªèÁêÜÂàô‰ΩøÁî®‰∏ÄÂ•ó**‚ÄúÈìÉÈìõÁ≥ªÁªü‚Äù**„ÄÇ

1.  ÁªèÁêÜÂëäËØâÈó®Âè£Ôºö‚ÄúÊúâÂÆ¢‰∫∫Êù•ÁöÑÊó∂ÂÄôÔºå**Êëá‰∏Ä‰∏ãÈìÉÈìõ**„ÄÇ‚Äù
2.  ÁÑ∂ÂêéÁªèÁêÜÂ∞±ÂéªÂøôÂà´ÁöÑ‰∫ã‰∫Ü„ÄÇ
3.  ÂΩìÂÆ¢‰∫∫ÁúüÁöÑÊù•‰∫ÜÔºåÈìÉÈìõÂìçËµ∑Ôºå‰∏Ä‰∏™ÁâπÊÆäÁöÑÂáΩÊï∞‚Äî‚ÄîÊàë‰ª¨Áß∞‰πã‰∏∫**ÂõûË∞ÉÂáΩÊï∞ÔºàCallbackÔºâ**‚Äî‚ÄîÂ∞±‰ºöË¢´Ëá™Âä®ÊâßË°å„ÄÇ

ËøôÈáåÁöÑ `xev` Â∫ìÂ∞±ÊòØ‰∏∫Êàë‰ª¨Êèê‰æõËøôÂ•ó‚ÄúÈìÉÈìõÁ≥ªÁªü‚ÄùÁöÑ„ÄÇËÆ©Êàë‰ª¨Ë∑üË∏™‰∏Ä‰∏™ËØ∑Ê±ÇÁöÑÂÆåÊï¥ÁîüÂëΩÂë®ÊúüÔºåÂπ∂ÈáçÁÇπÂÖ≥Ê≥® `xev` ÁöÑË∞ÉÁî®„ÄÇ

#### `listen()` ÂáΩÊï∞ÔºöÂºÄÈó®Ëê•‰∏ö

```zig
pub fn listen(self: *Server) !void {
    // ... ÁúÅÁï•Êó•ÂøóÊâìÂç∞ ...

    var loop = try xev.Loop.init(...); // 1. ÂáÜÂ§áÂ•Ω‰∫ã‰ª∂Âæ™ÁéØÔºà‚ÄúÁªèÁêÜÁöÑÂ§ßËÑë‚ÄùÔºâ
    defer loop.deinit();

    var tcp_server = try xev.TCP.init(address); // 2. ÂáÜÂ§áÂ•ΩTCPÊúçÂä°Âô®Ôºà‚ÄúÈ§êÂéÖÂ§ßÈó®‚ÄùÔºâ
    try tcp_server.bind(address);
    try tcp_server.listen(128); // 3. ÂºÄÂßãÁõëÂê¨Ôºà‚ÄúÊääÈó®ÊâìÂºÄ‚ÄùÔºâ

    // ...

    var accept_completion: xev.Completion = .{};
    tcp_server.accept(&loop, &accept_completion, Server, self, acceptCallback); // 4. ËÆæÁΩÆÈìÉÈìõ

    try loop.run(.until_done); // 5. ÂºÄÂßãÂ∑•‰ΩúÔºÅÔºà‚ÄúÁªèÁêÜÂºÄÂßãÂê¨ÊâÄÊúâÈìÉÈìõÁöÑÂ£∞Èü≥‚ÄùÔºâ
}
```

Á¨¨4Ê≠•ÊòØÁ¨¨‰∏Ä‰∏™ÂÖ≥ÈîÆÁöÑ `xev` Ë∞ÉÁî®Ôºö
*   `tcp_server.accept(...)`: ËøôÂè•ËØùÁöÑÊÑèÊÄùÊòØÔºö‚ÄúÂòøÔºå`xev`ÔºåËØ∑Â∏ÆÊàëÁõëÂê¨ `tcp_server` Ëøô‰∏™Â§ßÈó®„ÄÇ‚Äù
*   `&loop`: Âú®Âì™‰∏™‰∫ã‰ª∂Âæ™ÁéØ‰∏äÁõëÂê¨„ÄÇ
*   `Server, self, acceptCallback`: **ËøôÊòØÈ≠îÊ≥ïÁöÑÊ†∏ÂøÉÔºÅ** ÂÆÉÂëäËØâ `xev`Ôºö‚ÄúÂΩì‰∏Ä‰∏™Êñ∞ËøûÊé•Âà∞Êù•Êó∂Ôºà‰∫ã‰ª∂ÂèëÁîüÊó∂ÔºâÔºåËØ∑Ë∞ÉÁî® `acceptCallback` Ëøô‰∏™ÂáΩÊï∞ÔºåÂπ∂Êää `self`Ôºà‰πüÂ∞±ÊòØ `Server` ÁªèÁêÜÂØπË±°Ôºâ‰Ωú‰∏∫‰∏ä‰∏ãÊñá‰ø°ÊÅØÔºà`userdata`Ôºâ‰º†ÁªôÂÆÉ„ÄÇ‚Äù

#### `acceptCallback` ÂáΩÊï∞ÔºöÂÆ¢‰∫∫ËøõÈó®

ÂΩì‰∏Ä‰∏™Êñ∞ËøûÊé•ÁúüÁöÑÂà∞Êù•Êó∂Ôºå`xev` ‰ºöËá™Âä®Ë∞ÉÁî®Ëøô‰∏™ÂáΩÊï∞„ÄÇ

```zig
fn acceptCallback(...) xev.CallbackAction {
    // ...
    const client_tcp = result catch { ... }; // 1. ÊãøÂà∞‰∏éÊñ∞ÂÆ¢‰∫∫ÁöÑ‚ÄúÁîµËØùÁ∫ø‚Äù

    if (!server.connection_pool.tryAcquire()) { // 2. ÈóÆÈ¢Ü‰ΩçÂëòÊòØÂê¶Êª°Â∫ß
        // ... Êª°‰∫ÜÂ∞±ÊãíÁªù
    }

    // 3. ÂàÜÈÖç‰∏Ä‰∏™‚ÄúÊúçÂä°Âëò‚Äù(ClientConnection)
    const client_conn = ...;
    client_conn.* = ClientConnection.init(client_tcp, server, server.allocator);

    // 4. ËÆæÁΩÆ‰∏ã‰∏Ä‰∏™ÈìÉÈìõÔºÅ
    client_tcp.read(loop, &client_conn.read_completion, .{ .slice = &client_conn.buffer }, ClientConnection, client_conn, readCallback);

    return .rearm; // 5. ËøîÂõû .rearm
}
```

Á¨¨4Ê≠•ÊòØÁ¨¨‰∫å‰∏™ÂÖ≥ÈîÆÁöÑ `xev` Ë∞ÉÁî®Ôºö
*   `client_tcp.read(...)`: ÁªèÁêÜÂØπÊñ∞Êù•ÁöÑÊúçÂä°ÂëòËØ¥Ôºö‚ÄúÊ≥®ÊÑèÂê¨Ëøô‰ΩçÂÆ¢‰∫∫ÁÇπÈ§ê„ÄÇÂΩì‰ªñÂºÄÂßãËØ¥ËØùÔºàÂèëÈÄÅÊï∞ÊçÆÔºâÊó∂ÔºåÊëá‰∏Ä‰∏ãÈìÉÈìõ„ÄÇ‚Äù
*   `.slice = &client_conn.buffer`: ÊääÂÆ¢‰∫∫ËØ¥ÁöÑËØùÔºàÊï∞ÊçÆÔºâËÆ∞ÂΩïÂà∞Ëøô‰ΩçÊúçÂä°ÂëòÁöÑÁÇπÈ§êÊú¨ (`buffer`) Èáå„ÄÇ
*   `ClientConnection, client_conn, readCallback`: ÂëäËØâ `xev`Ôºö‚ÄúÂΩìÊï∞ÊçÆ‰º†Êù•Êó∂ÔºåËØ∑Ë∞ÉÁî® `readCallback` ÂáΩÊï∞ÔºåÂπ∂Êää `client_conn`ÔºàËøô‰ΩçÊúçÂä°ÂëòÔºâ‰Ωú‰∏∫‰∏ä‰∏ãÊñá‰º†ÁªôÂÆÉ„ÄÇ‚Äù

Á¨¨5Ê≠•ÁöÑ `return .rearm;` ‰πüÂæàÈáçË¶Å„ÄÇÂÆÉÂëäËØâ `xev`Ôºö‚ÄúËøôÊ¨°ÁöÑÂÆ¢‰∫∫ÊàëÂ§ÑÁêÜÂ•Ω‰∫ÜÔºåËØ∑**ÈáçÊñ∞ÈÉ®ÁΩ≤Ôºàre-armÔºâ**Ëøô‰∏™ `accept` ÈìÉÈìõÔºåÊàëËøòË¶ÅÁªßÁª≠Êé•ÂæÖ‰∏ã‰∏Ä‰ΩçÂÆ¢‰∫∫„ÄÇ‚Äù

#### `readCallback` ÂáΩÊï∞ÔºöÂÆ¢‰∫∫ÁÇπÈ§ê

ÂΩìÂÆ¢Êà∑Á´ØÂèëÈÄÅÊï∞ÊçÆÊó∂Ôºå`xev` ‰ºöË∞ÉÁî®Ëøô‰∏™ÂáΩÊï∞„ÄÇ

```zig
fn readCallback(...) xev.CallbackAction {
    // ...
    const bytes_read = result catch { ... }; // 1. Êî∂Âà∞ÂÆ¢‰∫∫ËØ¥ÁöÑËØùÔºàÊï∞ÊçÆÔºâ

    if (bytes_read == 0) { // 2. Â¶ÇÊûúÂÆ¢‰∫∫ÊåÇ‰∫ÜÁîµËØùÔºàËøûÊé•ÂÖ≥Èó≠Ôºâ
        client_conn.close(loop); // Â∞±ÁªìÊùüÊúçÂä°
        return .disarm;
    }

    // 3. ÊääÊï∞ÊçÆËøΩÂä†Âà∞ÂÆåÊï¥ÁöÑÁÇπÈ§êËÆ∞ÂΩï(request_buffer)Èáå
    // ...

    // 4. Ê£ÄÊü•ÂÆ¢‰∫∫ÊòØÂê¶ËØ¥ÂÆå‰∫ÜÂÆåÊï¥ÁöÑ‰∏ÄÂè•ËØùÔºàHTTPËØ∑Ê±ÇÊòØÂê¶ÂÆåÊï¥Ôºâ
    if (should_process) {
        // 5a. Â¶ÇÊûúËØ¥ÂÆå‰∫ÜÔºåÊääËÆ¢Âçï‰∫§ÁªôÂé®ÊàøÂ§ÑÁêÜ
        processHttpRequestFromBuffer(client_conn, loop) catch { ... };
        return .disarm; // ËÆ¢ÂçïÂ∑≤Êé•Êî∂ÔºåËøô‰∏™‚ÄúËØª‚ÄùÁöÑ‰ªªÂä°ÂÆåÊàê‰∫ÜÔºåËß£Èô§ÈÉ®ÁΩ≤
    } else {
        // 5b. Â¶ÇÊûúÊ≤°ËØ¥ÂÆåÔºåËÆæÁΩÆÂêå‰∏Ä‰∏™ÈìÉÈìõÔºåÁªßÁª≠Âê¨
        client_conn.tcp.read(loop, &client_conn.read_completion, ...);
        return .disarm; // ÊóßÁöÑ‚ÄúËØª‚Äù‰ªªÂä°ÂÆåÊàêÔºå‰ΩÜÊàë‰ª¨È©¨‰∏äËÆæ‰∫Ü‰∏™Êñ∞ÁöÑÔºåÊïàÊûúÁ±ª‰ººÈáçÊñ∞ÈÉ®ÁΩ≤
    }
}
```
`return .disarm;` ÁöÑÊÑèÊÄùÊòØÔºö‚ÄúËøôÊ¨°ÁöÑ‚ÄòËØª‚Äô‰∫ã‰ª∂ÊàëÂ§ÑÁêÜÂÆå‰∫ÜÔºåËØ∑**Ëß£Èô§ÈÉ®ÁΩ≤ÔºàdisarmÔºâ**Ëøô‰∏™ÈìÉÈìõ„ÄÇÊàë‰∏çÈúÄË¶Å‰Ω†ÂÜç‰∏∫**ËøôÊ¨°**ËØªÊìç‰ΩúÈÄöÁü•Êàë‰∫Ü„ÄÇ‚Äù ÔºàÂ¶ÇÊûúÈúÄË¶ÅÁªßÁª≠ËØªÔºåÊàë‰ª¨‰ºöÊâãÂä®ËÆæÁΩÆ‰∏Ä‰∏™Êñ∞ÁöÑ `read` ‰ªªÂä°ÔºåÂ∞±ÂÉè `5b` ÈÇ£Ê†∑Ôºâ„ÄÇ

#### `processHttpRequestFromBuffer` ÂáΩÊï∞ÔºöÂé®ÊàøÂ§ÑÁêÜËÆ¢Âçï

Ëøô‰∏™ÂáΩÊï∞‰∏çÊòØÂõûË∞ÉÔºåËÄåÊòØÊàë‰ª¨Ëá™Â∑±ÁöÑÈÄªËæë„ÄÇÂÆÉËß£ÊûêËØ∑Ê±ÇÔºåÈÄöËøá `router`ÔºàËèúÂçïÔºâÊâæÂà∞ÂØπÂ∫îÁöÑÂ§ÑÁêÜÂáΩÊï∞ÔºàÂé®Â∏àÔºâÔºåÁîüÊàê `HttpResponse`ÔºàËèúÂìÅÔºâÔºåÁÑ∂ÂêéË∞ÉÁî® `sendResponse` ‰∏äËèú„ÄÇ

#### `sendResponse` & `writeCallback` ÂáΩÊï∞Ôºö‰∏äËèú‰∏éÁ°ÆËÆ§

`sendResponse` ÂáΩÊï∞ÈáåÊúâÁ¨¨‰∏â‰∏™ÂÖ≥ÈîÆÁöÑ `xev` Ë∞ÉÁî®Ôºö
```zig
fn sendResponse(...) {
    // ...
    client_conn.response_data = response_data; // ÈáçË¶ÅÔºöÂÖàÊääËèúÁ´ØÂú®ÊâòÁõò‰∏äÔºåÈò≤Ê≠¢Ë¢´ÂõûÊî∂
    client_conn.tcp.write(loop, &client_conn.write_completion, .{ .slice = response_data }, ClientConnection, client_conn, writeCallback);
}
```
*   `client_conn.tcp.write(...)`: ‚ÄúÂòøÔºå`xev`ÔºåËØ∑ÊääËøô‰ªΩ `response_data`ÔºàËèúÔºâÂèëÁªôÂÆ¢‰∫∫„ÄÇÂèëÈÄÅ**ÂÆåÊàê**ÂêéÔºåËØ∑Êëá‰∏Ä‰∏ãÈìÉÈìõÔºåË∞ÉÁî® `writeCallback` ÂáΩÊï∞„ÄÇ‚Äù

ÂΩìÊï∞ÊçÆÂèëÈÄÅÂÆåÊØïÂêéÔºå`writeCallback` Ë¢´Ë∞ÉÁî®Ôºö
```zig
fn writeCallback(...) xev.CallbackAction {
    // ...
    log.info("‚úÖ Sent {} bytes response", .{bytes_written}); // Á°ÆËÆ§ËèúÂ∑≤ÈÄÅÂà∞

    // ‰∏äÂÆåËèúÔºåÊúçÂä°ÁªìÊùü
    client_conn.close(loop);
    return .disarm; // ‚ÄúÂÜô‚Äù‰ªªÂä°ÂÆåÊàêÔºåËß£Èô§ÈÉ®ÁΩ≤
}
```
#### `closeCallback` ÂáΩÊï∞ÔºöÂÆ¢‰∫∫Á¶ªÂ∏≠

`writeCallback` Ë∞ÉÁî® `client_conn.close(loop)`ÔºåËÄå `close` ÂáΩÊï∞ÂÜÖÈÉ®‰ºöËÆæÁΩÆÊúÄÂêé‰∏Ä‰∏™ÈìÉÈìõÔºö
```zig
fn close(...) {
    // ...
    self.tcp.close(loop, &self.close_completion, ClientConnection, self, closeCallback);
}
```
*   `self.tcp.close(...)`: ‚ÄúÂòø `xev`ÔºåËØ∑ÂÖ≥Èó≠Ëøô‰∏™ËøûÊé•„ÄÇÂΩì**ÂÆåÂÖ®ÂÖ≥Èó≠**ÂêéÔºåËØ∑ÊëáÈìÉÔºåË∞ÉÁî® `closeCallback`„ÄÇ‚Äù

ÂΩìËøûÊé•ÂΩªÂ∫ïÊñ≠ÂºÄÂêéÔºå`closeCallback` Ë¢´Ë∞ÉÁî®ÔºåÂÆÉ‰ºöÊâßË°åÊúÄÁªàÁöÑÊ∏ÖÁêÜÂ∑•‰ΩúÔºåÊØîÂ¶ÇÈáäÊîæÊúçÂä°Âëò `client_conn` Âç†Áî®ÁöÑÊâÄÊúâÂÜÖÂ≠ò (`client_conn.deinit()`)„ÄÇ

---

### ÊÄªÁªì

Ëøô‰∏™ `lib.zig` Êñá‰ª∂ÈÄöËøáÂá†‰∏™Ê†∏ÂøÉÁöÑ `struct` Êù•ÁÆ°ÁêÜÁä∂ÊÄÅÔºåÂπ∂Âà©Áî® `xev` Â∫ìÊèê‰æõÁöÑ**‰∫ã‰ª∂Âæ™ÁéØÂíåÂõûË∞ÉÊú∫Âà∂**ÔºåÊûÑÂª∫‰∫Ü‰∏Ä‰∏™È´òÊïàÁöÑÂºÇÊ≠•ÊúçÂä°Âô®„ÄÇ

Êï¥‰∏™ÊµÅÁ®ãÂ∞±ÂÉè‰∏Ä‰∏™È´òÂ∫¶ÂçèÂêåÁöÑÈ§êÂéÖÔºö
1.  `listen`ÔºöÈ§êÂéÖÂºÄÈó®ÔºåÁªèÁêÜÂºÄÂßãÂÖ≥Ê≥®Â§ßÈó®ÁöÑ `accept` ÈìÉÈìõ„ÄÇ
2.  `acceptCallback`ÔºöÂÆ¢‰∫∫ËøõÈó®ÔºåÂàÜÈÖç‰∏Ä‰∏™ÊúçÂä°ÂëòÔºåÂπ∂ËÆ©ÊúçÂä°ÂëòÂÖ≥Ê≥®ÂÆ¢‰∫∫ÁöÑ `read` ÈìÉÈìõ„ÄÇ
3.  `readCallback`ÔºöÂÆ¢‰∫∫ÁÇπÈ§êÔºåÊúçÂä°ÂëòËÆ∞ÂΩïÔºåÁÇπÂÆåÂêéÊääËÆ¢ÂçïÈÄÅÂéªÂé®Êàø„ÄÇ
4.  `processHttpRequest...`ÔºöÂé®ÊàøÂÅöËèú„ÄÇ
5.  `sendResponse`ÔºöÊúçÂä°Âëò‰∏äËèúÔºåÂπ∂ÂÖ≥Ê≥® `write` ÈìÉÈìõÔºåÁ°ÆËÆ§ÂÆ¢‰∫∫Êî∂Âà∞„ÄÇ
6.  `writeCallback`ÔºöÂÆ¢‰∫∫Êî∂Âà∞ËèúÔºåÊúçÂä°ÂëòÂºÄÂßãÊ∏ÖÁêÜÊ°åÈù¢Ôºà`close`Ôºâ„ÄÇ
7.  `closeCallback`ÔºöÂÆ¢‰∫∫Á¶ªÂ∏≠ÔºåÊúçÂä°ÂëòÂíåÊ°åÂ≠êË¢´ÂÆåÂÖ®ÈáäÊîæÔºåÂèØ‰ª•ÊúçÂä°‰∏ã‰∏Ä‰ΩçÂÆ¢‰∫∫„ÄÇ

Êï¥‰∏™ËøáÁ®ãÔºåÁªèÁêÜÔºà‰∏ªÁ∫øÁ®ãÔºâ‰ªé‰∏çÁ≠âÂæÖ‰ªª‰Ωï‰∏Ä‰∏™ÂÆ¢‰∫∫Ôºå‰ªñÂè™ÂìçÂ∫îÂêÑÁßç‚ÄúÈìÉÈìõ‚ÄùÂ£∞ÔºåÂõ†Ê≠§ÂèØ‰ª•ÂêåÊó∂‰∏∫ÊàêÂçÉ‰∏ä‰∏áÁöÑÂÆ¢‰∫∫Êèê‰æõÈ´òÊïàÊúçÂä°„ÄÇËøôÂ∞±ÊòØÂºÇÊ≠•ÁºñÁ®ãÁöÑÂ®ÅÂäõÔºÅ


cmpxchgWeak ‰∏∫‰ªÄ‰πà‰∏çÁõ¥Êé•Áî® fetchAdd Ôºü

ËøôÊòØ‰∏Ä‰∏™ÊûÅÂÖ∂Ê∑±ÂàªÂíåÂá∫Ëâ≤ÁöÑÈóÆÈ¢òÔºÅÂÆÉÁõ¥Êé•Ëß¶Âèä‰∫ÜÂπ∂ÂèëÁºñÁ®ã‰∏≠ÁÆóÊ≥ïËÆæËÆ°ÁöÑÊ†∏ÂøÉ„ÄÇ‰Ω†ÈóÆÂà∞‰∫ÜÁÇπÂ≠ê‰∏ä„ÄÇ

‰∏∫‰ªÄ‰πàÂú® tryAcquire ‰∏≠‰∏çÁõ¥Êé•Áî® fetchAdd(1, .acq_rel) ËÄåÊòØÁî®‰∏Ä‰∏™ÁúãËµ∑Êù•Êõ¥Â§çÊùÇÁöÑ cmpxchgWeak Âæ™ÁéØÂë¢Ôºü

ÁÆÄÁü≠ÁöÑÂõûÁ≠îÊòØÔºöÊàë‰ª¨ÈúÄË¶ÅÂú®Â¢ûÂä†ËÆ°Êï∞ÂÄº‰πãÂâçÔºåÂÖàÂÅö‰∏Ä‰∏™Ê£ÄÊü•Ôºàif (current >= self.max_connections)Ôºâ„ÄÇfetchAdd Êó†Ê≥ïÂ∞ÜËøô‰∏™Ê£ÄÊü•ÂíåÂ¢ûÂä†Êìç‰ΩúÁªëÂÆöÊàê‰∏Ä‰∏™ÂéüÂ≠êÊ≠•È™§„ÄÇ

ËØ¶ÁªÜËß£ÊûêÔºöÂéüÂ≠êÊìç‰ΩúÁöÑ‚Äú‰∏çÂèØÂàÜÂâ≤ÊÄß‚Äù

Êàë‰ª¨ÂÜçÂõûÈ°æ‰∏Ä‰∏ã‚ÄúÂéüÂ≠ê‚ÄùÁöÑÂÆö‰πâÔºö‰∏çÂèØÂàÜÂâ≤„ÄÇ

fetchAdd(1, ...) ÊòØ‰∏Ä‰∏™Âçï‰∏ÄÁöÑ„ÄÅÂéüÂ≠êÁöÑÊìç‰Ωú„ÄÇÂÆÉÁöÑÂÖ®ÈÉ®ËÅåË¥£Â∞±ÊòØÔºö‚ÄúÊääÂÄºÂä†1‚Äù„ÄÇÂÆÉÂÅöÂæóÈùûÂ∏∏Âá∫Ëâ≤Ôºå‰ΩÜ‰πüÂ∞±‰ªÖÊ≠§ËÄåÂ∑≤„ÄÇ

Êàë‰ª¨ÁöÑ tryAcquire ÈÄªËæëÈúÄË¶ÅÂÅö‰∏§‰ª∂‰∫ãÔºö

Ê£ÄÊü•ÔºöÂΩìÂâçËøûÊé•Êï∞ÊòØÂê¶Â∞è‰∫éÊúÄÂ§ßÈôêÂà∂Ôºü

Â¢ûÂä†ÔºöÂ¶ÇÊûúÂ∞è‰∫éÔºåÂ∞±ÊääËøûÊé•Êï∞Âä†1„ÄÇ

Â¶ÇÊûúÊàë‰ª¨Â∞ùËØïÁî® fetchAdd Êù•ÂÆûÁé∞Ôºå‰ª£Á†ÅÂèØËÉΩ‰ºöÂÉèËøôÊ†∑ÔºàËøôÊòØÈîôËØØÁ§∫ËåÉÔºÅÔºâÔºö

code
Zig
download
content_copy
expand_less

// ÈîôËØØÁ§∫ËåÉÔºöÊó†Ê≥ïÂ∑•‰ΩúÁöÑ tryAcquire
fn tryAcquire_WRONG(self: *ConnectionPool) bool {
    // Á¨¨‰∏ÄÊ≠•ÔºöÂÖàËØªÂèñÂΩìÂâçÂÄº
    const current = self.active_connections.load(.acquire);

    // Á¨¨‰∫åÊ≠•ÔºöÊ£ÄÊü•
    if (current >= self.max_connections) {
        return false;
    }

    // Á¨¨‰∏âÊ≠•ÔºöÂ¢ûÂä†
    // ÈóÆÈ¢òÊù•‰∫ÜÔºÅ
    _ = self.active_connections.fetchAdd(1, .acq_rel);

    return true;
}

ËøôÊÆµ‰ª£Á†ÅÂ≠òÂú®‰∏Ä‰∏™Â∑®Â§ßÁöÑÁ´ûÊÄÅÊù°‰ª∂ÔºàRace ConditionÔºâÔºåÊàë‰ª¨Áî®‰∏Ä‰∏™Âú∫ÊôØÊù•ËØ¥ÊòéÔºö

ÂÅáËÆæ max_connections ÊòØ 100„ÄÇ

Á∫øÁ®ãA ÊâßË°åÂà∞Á¨¨‰∏ÄÊ≠•ÔºåËØªÂèñ current ‰∏∫ 99„ÄÇ

Á∫øÁ®ãB ‰πüÊâßË°åÂà∞Á¨¨‰∏ÄÊ≠•Ôºå‰πüËØªÂèñ current ‰∏∫ 99„ÄÇ

Á∫øÁ®ãA ÊâßË°åÁ¨¨‰∫åÊ≠•Ôºå99 < 100ÔºåÊ£ÄÊü•ÈÄöËøá„ÄÇ

Á∫øÁ®ãB ‰πüÊâßË°åÁ¨¨‰∫åÊ≠•Ôºå99 < 100ÔºåÊ£ÄÊü•‰πüÈÄöËøá„ÄÇ

Á∫øÁ®ãA ÊâßË°åÁ¨¨‰∏âÊ≠•ÔºåË∞ÉÁî® fetchAddÔºåactive_connections ÂèòÊàê‰∫Ü 100„ÄÇ

Á∫øÁ®ãB ‰πüÊâßË°åÁ¨¨‰∏âÊ≠•ÔºåË∞ÉÁî® fetchAddÔºåactive_connections ÂèòÊàê‰∫Ü 101ÔºÅ

ÁÅæÈöæÂèëÁîü‰∫ÜÔºÅ Êàë‰ª¨Á™ÅÁ†¥‰∫Ü max_connections ÁöÑÈôêÂà∂„ÄÇÊúçÂä°Âô®ÁöÑÈÄªËæëË¢´Á†¥Âùè‰∫Ü„ÄÇ

ÈóÆÈ¢òÂ∞±Âá∫Âú®**‚ÄúÊ£ÄÊü•‚ÄùÂíå‚ÄúÂ¢ûÂä†‚ÄùËøô‰∏§‰∏™Ê≠•È™§‰∏çÊòØÂéüÂ≠êÁöÑ**„ÄÇÂú®ÂÆÉ‰ª¨‰πãÈó¥Â≠òÂú®‰∏Ä‰∏™Êó∂Èó¥Á™óÂè£ÔºåÂÖ∂‰ªñÁ∫øÁ®ãÂèØ‰ª•Ë∂ÅËôöËÄåÂÖ•„ÄÇ

cmpxchg Âæ™ÁéØÁöÑÂ®ÅÂäõÔºöÂ∞Ü‚ÄúÊ£ÄÊü•‚Äù‰∏é‚Äú‰øÆÊîπ‚ÄùÊçÜÁªë

Áé∞Âú®ÔºåÊàë‰ª¨ÂÜçÂõûÂ§¥Áúã cmpxchgWeak Âæ™ÁéØÁöÑÂÆûÁé∞Ôºö

code
Zig
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
fn tryAcquire(self: *ConnectionPool) bool {
    while (true) {
        // 1. ËØªÂèñÂΩìÂâçÂÄº (Êàë‰ª¨ÁöÑ‚ÄúÁåúÊµã‚Äù)
        const current = self.active_connections.load(.acquire);

        // 2. Âü∫‰∫éÁåúÊµãËøõË°åÊ£ÄÊü•
        if (current >= self.max_connections) {
            return false;
        }

        // 3. Â∞ùËØïÂéüÂ≠êÊÄßÂú∞‚ÄúÁ°ÆËÆ§ÁåúÊµãÂπ∂‰øÆÊîπ‚Äù
        if (self.active_connections.cmpxchgWeak(current, current + 1, ...) == null) {
            // ÊàêÂäüÔºÅ
            return true;
        }
        // Â¶ÇÊûúÂ§±Ë¥•ÔºåÂæ™ÁéØ‰ºöÁ´ãÂç≥ÈáçËØï
    }
}

Ëøô‰∏™Âæ™ÁéØÂ∑ßÂ¶ôÂú∞Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇcmpxchgWeak Ëøô‰∏™Êìç‰ΩúÊú¨Ë∫´Â∞±ÂåÖÂê´‰∫Ü**‚ÄúÊ£ÄÊü•ÔºàÊØîËæÉÔºâ‚Äù** Âíå ‚Äú‰øÆÊîπÔºà‰∫§Êç¢Ôºâ‚Äù„ÄÇ

ËÆ©Êàë‰ª¨Áî®ÂêåÊ†∑ÁöÑÂú∫ÊôØÂÜçËµ∞‰∏ÄÈÅçÊµÅÁ®ãÔºö

max_connections ÊòØ 100„ÄÇactive_connections ÂΩìÂâçÊòØ 99„ÄÇ

Á∫øÁ®ãA ËøõÂÖ•Âæ™ÁéØÔºö

load ÂæóÂà∞ current ÊòØ 99„ÄÇ

Ê£ÄÊü• 99 < 100 ÈÄöËøá„ÄÇ

Â∞ùËØï cmpxchgWeak(99, 100, ...)„ÄÇ

Â∞±Âú®Á∫øÁ®ãAÂ∞ùËØï cmpxchg ÁöÑÁû¨Èó¥ÔºåCPUÂàáÊç¢Âà∞‰∫Ü Á∫øÁ®ãB„ÄÇ

Á∫øÁ®ãB ËøõÂÖ•Âæ™ÁéØÔºö

load ÂæóÂà∞ current ÊòØ 99„ÄÇ

Ê£ÄÊü• 99 < 100 ÈÄöËøá„ÄÇ

Â∞ùËØï cmpxchgWeak(99, 100, ...)„ÄÇÂÅáËÆæ Á∫øÁ®ãB ÂÖàÊàêÂäü‰∫Ü„ÄÇ

active_connections ÁöÑÂÄºÁé∞Âú®ÂéüÂ≠êÊÄßÂú∞ÂèòÊàê‰∫Ü 100„ÄÇ

Á∫øÁ®ãBÁöÑ tryAcquire ËøîÂõû true„ÄÇ

CPUÂàáÊç¢Âõû Á∫øÁ®ãAÔºåÁªßÁª≠ÊâßË°åÂÆÉÁöÑ cmpxchgWeak(99, 100, ...)„ÄÇ

CPUÁé∞Âú®ËøõË°åÊØîËæÉÔºö‚ÄúÂòøÔºåactive_connections ÁöÑÂÄºËøòÊòØ 99 ÂêóÔºü‚Äù

Á≠îÊ°àÊòØÔºö‚Äú‰∏çÊòØÔºÅÂÆÉÁé∞Âú®ÊòØ 100 ‰∫ÜÔºÅ‚Äù

‰∫éÊòØÔºåcmpxchgWeak Â§±Ë¥•Ôºå‰∏çÊâßË°å‰ªª‰Ωï‰øÆÊîπ„ÄÇ

Á∫øÁ®ãA ÁöÑ if Âà§Êñ≠Â§±Ë¥•ÔºåÂÆÉ‰∏ç‰ºöËøîÂõû true„ÄÇÂÆÉ‰ºöÂõûÂà∞ while Âæ™ÁéØÁöÑÈ°∂ÈÉ®ÔºåÂºÄÂßãÊñ∞‰∏ÄËΩÆÁöÑÂ∞ùËØï„ÄÇ

Á∫øÁ®ãA ÁöÑÁ¨¨‰∫åËΩÆÂæ™ÁéØÔºö

load ÂæóÂà∞ current ÊòØ 100„ÄÇ

Ê£ÄÊü• 100 >= 100ÔºåÊù°‰ª∂ÊàêÁ´ã„ÄÇ

if ËØ≠Âè•ÊâßË°åÔºåÂáΩÊï∞ËøîÂõû false„ÄÇ

ÊúÄÁªàÁªìÊûúÔºö ‰∏Ä‰∏™Á∫øÁ®ãÊàêÂäüÂú∞Â∞ÜËÆ°Êï∞Âô®Âä†Âà∞‰∫Ü 100ÔºåÂè¶‰∏Ä‰∏™Á∫øÁ®ãÂÆâÂÖ®Âú∞Â§±Ë¥•‰∫Ü„ÄÇËøûÊé•Êï∞‰ªéÊú™Ë∂ÖËøá 100„ÄÇÈÄªËæëÂÆåÁæéÊó†Áº∫„ÄÇ

ÊÄªÁªì

cmpxchgÔºàCompare-and-SwapÔºåÊØîËæÉÂπ∂‰∫§Êç¢ÔºâÊòØÂÆûÁé∞ÊâÄË∞ìÁöÑ**‚ÄúÊó†ÈîÅÔºàLock-FreeÔºâ‚Äù**ÁÆóÊ≥ïÁöÑÂü∫Áü≥„ÄÇËøô‰∏™Âæ™ÁéØÊ®°ÂºèË¢´Áß∞‰∏∫ CAS Loop„ÄÇ

ÂΩì‰Ω†ÁöÑÈÄªËæëÊòØÁÆÄÂçïÁöÑ**‚ÄúÊó†Êù°‰ª∂‰øÆÊîπ‚Äù**ÔºàÊØîÂ¶Ç release Êó∂Êó†Êù°‰ª∂Âáè1ÔºâÔºåÈÇ£‰πà fetchAdd / fetchSub ÊòØÊúÄ‰Ω≥ÈÄâÊã©ÔºåÂõ†‰∏∫ÂÆÉÊõ¥ÁÆÄÂçï„ÄÅÊÑèÂõæÊõ¥ÊòéÁ°Æ„ÄÇ

ÂΩì‰Ω†ÈúÄË¶Å**‚ÄúÊúâÊù°‰ª∂ÁöÑ‰øÆÊîπ‚Äù**ÔºàÊØîÂ¶Ç tryAcquire Êó∂ÔºåÂè™ÊúâÂú®Êú™Êª°ÁöÑÊÉÖÂÜµ‰∏ãÊâçÂä†1ÔºâÔºåfetchAdd Â∞±Êó†ËÉΩ‰∏∫Âäõ‰∫ÜÔºåÂõ†‰∏∫‰Ω†Êó†Ê≥ïÊää‰Ω†ÁöÑ‚ÄúÊù°‰ª∂‚ÄùÂ°ûËøõËøô‰∏™ÂéüÂ≠êÊìç‰ΩúÈáå„ÄÇËøôÊó∂ÔºåCAS Loop Â∞±ÊòØÊ†áÂáÜÁöÑ„ÄÅÊúÄÈ´òÊïàÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇÂÆÉÂÖÅËÆ∏‰Ω†Âú®ÊôÆÈÄö‰ª£Á†Å‰∏≠ËøõË°å‰ªªÊÑèÂ§çÊùÇÁöÑÈÄªËæëÂà§Êñ≠ÔºåÁÑ∂ÂêéÈÄöËøá‰∏ÄÊ¨°ÂéüÂ≠êÁöÑ cmpxchg Êìç‰ΩúÊù•Êèê‰∫§‰Ω†ÁöÑ‰øÆÊîπÔºåÂêåÊó∂Á°Æ‰øùÂú®Ê≠§ÊúüÈó¥ÂÖ±‰∫´Áä∂ÊÄÅÊ≤°ÊúâË¢´ÂÖ∂‰ªñ‰∫∫ÊîπÂèò„ÄÇ
