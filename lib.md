```zig
/// lib.zig

//! libxev-http: High-performance async HTTP framework for Zig
//!
//! A modern, production-ready HTTP server built on libxev for maximum performance
//! and cross-platform compatibility.
//!
//! ## Features
//! - Async event-driven architecture using libxev
//! - High-performance routing with parameter extraction
//! - Middleware support for request/response processing
//! - Memory-safe HTTP parsing and response building
//! - Cross-platform compatibility (Linux, macOS, Windows)
//! - Production-ready security features

const std = @import("std");
const xev = @import("xev");
const net = std.net;
const log = std.log;
const security = @import("security.zig");
const middleware = @import("middleware.zig");

// Version information
pub const version = "1.0.0";
pub const version_major = 1;
pub const version_minor = 0;
pub const version_patch = 0;

// Re-export commonly used types
pub const Allocator = std.mem.Allocator;
pub const ArrayList = std.ArrayList;
pub const StringHashMap = std.StringHashMap;

// Re-export core modules
pub const HttpRequest = @import("request.zig").HttpRequest;
pub const HttpMethod = @import("request.zig").HttpMethod;
pub const HttpResponse = @import("response.zig").HttpResponse;
pub const StatusCode = @import("response.zig").StatusCode;
pub const Context = @import("context.zig").Context;
pub const Router = @import("router.zig").Router;
pub const Route = @import("router.zig").Route;
pub const HandlerFn = @import("router.zig").HandlerFn;

// Re-export utility modules
pub const Buffer = @import("buffer.zig").Buffer;
pub const BufferPool = @import("buffer.zig").BufferPool;
pub const BufferPoolStats = @import("buffer.zig").BufferPoolStats;
pub const HttpConfig = @import("config.zig").HttpConfig;
pub const AppConfig = @import("config.zig").AppConfig;
pub const loadConfig = @import("config.zig").loadConfig;

// Re-export security modules
pub const Security = @import("security.zig");
pub const SecurityLimits = @import("security.zig").SecurityLimits;
pub const SecurityResult = @import("security.zig").SecurityResult;
pub const ConnectionTiming = @import("security.zig").ConnectionTiming;

// Re-export middleware modules
pub const MiddlewareFn = middleware.MiddlewareFn;
pub const NextFn = middleware.NextFn;
pub const MiddlewareChain = middleware.MiddlewareChain;
pub const Middleware = middleware.Middleware;

// Built-in middleware
pub const loggingMiddleware = middleware.loggingMiddleware;
pub const corsMiddleware = middleware.corsMiddleware;
pub const securityHeadersMiddleware = middleware.securityHeadersMiddleware;
pub const requestIdMiddleware = middleware.requestIdMiddleware;
pub const rateLimitMiddleware = middleware.rateLimitMiddleware;
pub const basicAuthMiddleware = middleware.basicAuthMiddleware;
pub const jsonBodyParserMiddleware = middleware.jsonBodyParserMiddleware;
pub const errorHandlerMiddleware = middleware.errorHandlerMiddleware;
pub const compressionMiddleware = middleware.compressionMiddleware;

/// Client connection context for handling HTTP requests
const ClientConnection = struct {
    tcp: xev.TCP,
    server: *Server,
    allocator: Allocator,
    buffer: [8192]u8,
    read_completion: xev.Completion,
    write_completion: xev.Completion,
    close_completion: xev.Completion,
    read_len: usize,
    total_read: usize,
    response_data: ?[]u8,
    is_closing: bool,
    timing: security.ConnectionTiming,
    request_buffer: std.ArrayList(u8),

    fn init(tcp: xev.TCP, server: *Server, allocator: Allocator) ClientConnection {
        return ClientConnection{
            .tcp = tcp,
            .server = server,
            .allocator = allocator,
            .buffer = undefined,
            .read_len = 0,
            .total_read = 0,
            .read_completion = .{},
            .write_completion = .{},
            .close_completion = .{},
            .response_data = null,
            .is_closing = false,
            .timing = security.ConnectionTiming.init(),
            .request_buffer = std.ArrayList(u8).init(allocator),
        };
    }

    fn deinit(self: *ClientConnection) void {
        // Clean up response data
        if (self.response_data) |data| {
            self.allocator.free(data);
        }

        // Clean up request buffer
        self.request_buffer.deinit();

        // Destroy the connection object
        self.allocator.destroy(self);
    }

    fn close(self: *ClientConnection, loop: *xev.Loop) void {
        if (self.is_closing) return;
        self.is_closing = true;

        // Release connection pool slot immediately
        self.server.connection_pool.release();

        // Gracefully close TCP connection
        self.tcp.close(loop, &self.close_completion, ClientConnection, self, closeCallback);
    }

    /// Check if connection has timed out or has processing issues
    fn checkTimeouts(self: *ClientConnection) bool {
        const result = security.checkRequestTimeouts(&self.timing, self.server.config);

        switch (result) {
            .allowed => return false,
            .connection_timeout => {
                log.warn("‚è∞ Connection timeout exceeded", .{});
                return true;
            },
            .idle_timeout => {
                log.warn("‚è∞ Idle timeout exceeded", .{});
                return true;
            },
            .processing_timeout => {
                log.warn("‚è±Ô∏è Request processing timeout", .{});
                return true;
            },
            else => {
                log.warn("üö´ Request validation failed: {s}", .{security.getSecurityResultDescription(result)});
                return true;
            },
        }
    }
};

/// Server status information
pub const ServerStatus = struct {
    active_connections: u32,
    max_connections: u32,
    routes_count: u32,
};

/// Connection pool for managing active connections
const ConnectionPool = struct {
    active_connections: std.atomic.Value(u32),
    max_connections: u32,

    fn init(max_connections: u32) ConnectionPool {
        return ConnectionPool{
            .active_connections = std.atomic.Value(u32).init(0),
            .max_connections = max_connections,
        };
    }

    fn tryAcquire(self: *ConnectionPool) bool {
        while (true) {
            const current = self.active_connections.load(.acquire);
            if (current >= self.max_connections) {
                return false;
            }
            if (self.active_connections.cmpxchgWeak(current, current + 1, .acq_rel, .acquire) == null) {
                return true;
            }
        }
    }

    fn release(self: *ConnectionPool) void {
        _ = self.active_connections.fetchSub(1, .acq_rel);
    }

    fn getActiveCount(self: *ConnectionPool) u32 {
        return self.active_connections.load(.acquire);
    }
};

/// HTTP server built on libxev
pub const Server = struct {
    allocator: Allocator,
    host: []const u8,
    port: u16,
    router: *Router,
    connection_pool: ConnectionPool,
    config: HttpConfig,

    pub fn init(allocator: Allocator, host: []const u8, port: u16) !Server {
        return initWithConfig(allocator, host, port, HttpConfig{});
    }

    pub fn initWithMaxConnections(allocator: Allocator, host: []const u8, port: u16, max_connections: u32) !Server {
        var config = HttpConfig{};
        config.max_connections = max_connections;
        return initWithConfig(allocator, host, port, config);
    }

    pub fn initWithConfig(allocator: Allocator, host: []const u8, port: u16, config: HttpConfig) !Server {
        const router = try Router.init(allocator);

        return Server{
            .allocator = allocator,
            .host = host,
            .port = port,
            .router = router,
            .connection_pool = ConnectionPool.init(@intCast(config.max_connections)),
            .config = config,
        };
    }

    pub fn deinit(self: *Server) void {
        self.router.deinit();
        self.allocator.destroy(self.router);
    }

    /// Add a GET route
    pub fn get(self: *Server, path: []const u8, handler: HandlerFn) !*Route {
        return try self.router.get(path, handler);
    }

    /// Add a POST route
    pub fn post(self: *Server, path: []const u8, handler: HandlerFn) !*Route {
        return try self.router.post(path, handler);
    }

    /// Add a PUT route
    pub fn put(self: *Server, path: []const u8, handler: HandlerFn) !*Route {
        return try self.router.put(path, handler);
    }

    /// Add a DELETE route
    pub fn delete(self: *Server, path: []const u8, handler: HandlerFn) !*Route {
        return try self.router.delete(path, handler);
    }

    /// Add global middleware that applies to all routes
    pub fn use(self: *Server, name: []const u8, middleware_fn: MiddlewareFn) !void {
        return try self.router.use(name, middleware_fn);
    }

    /// Check if thread pool is enabled
    pub fn hasThreadPool(self: *Server) bool {
        return self.config.enable_thread_pool;
    }

    /// Get server status information
    pub fn getStatus(self: *Server) ServerStatus {
        return ServerStatus{
            .active_connections = self.connection_pool.getActiveCount(),
            .max_connections = self.connection_pool.max_connections,
            .routes_count = @intCast(self.router.routes.items.len),
        };
    }

    /// Start the HTTP server with complete HTTP processing
    pub fn listen(self: *Server) !void {
        log.info("üöÄ Starting libxev-http server on {s}:{}", .{ self.host, self.port });
        log.info("üéØ Routes registered: {}", .{self.router.routes.items.len});
        log.info("üîó Max connections: {}", .{self.connection_pool.max_connections});

        // Show registered routes
        for (self.router.routes.items) |route| {
            log.info("   üìç {any} {s}", .{ route.method, route.pattern });
        }

        // Initialize libxev thread pool if enabled
        var libxev_thread_pool: ?xev.ThreadPool = null;
        if (self.config.enable_thread_pool) {
            libxev_thread_pool = xev.ThreadPool.init(.{
                .max_threads = if (self.config.thread_pool_size == 0)
                    @max(1, @as(u32, @intCast(std.Thread.getCpuCount() catch 4)))
                else
                    self.config.thread_pool_size,
                .stack_size = self.config.thread_pool_stack_size,
            });
            log.info("üßµ libxev ThreadPool initialized with {} max threads", .{libxev_thread_pool.?.max_threads});
        }
        defer if (libxev_thread_pool) |*pool| pool.deinit();

        // Initialize libxev event loop with optional thread pool
        var loop = try xev.Loop.init(.{
            .thread_pool = if (libxev_thread_pool) |*pool| pool else null,
        });
        defer loop.deinit();

        // Create TCP server
        const address = try net.Address.parseIp(self.host, self.port);
        var tcp_server = try xev.TCP.init(address);

        // Bind and listen
        try tcp_server.bind(address);
        try tcp_server.listen(128);

        log.info("‚úÖ Server listening on http://{s}:{}", .{ self.host, self.port });
        log.info("üîÑ Server running... Press Ctrl+C to stop", .{});

        // Start accepting connections
        var accept_completion: xev.Completion = .{};
        tcp_server.accept(&loop, &accept_completion, Server, self, acceptCallback);

        // Run the event loop
        try loop.run(.until_done);
    }
};

/// Callback for closing connections
fn closeCallback(
    userdata: ?*ClientConnection,
    loop: *xev.Loop,
    completion: *xev.Completion,
    tcp: xev.TCP,
    result: xev.CloseError!void,
) xev.CallbackAction {
    _ = loop;
    _ = completion;
    _ = tcp;
    const client_conn = userdata.?;

    result catch |err| {
        log.warn("Connection close error (expected): {any}", .{err});
    };

    log.info("üîí Connection closed", .{});
    client_conn.deinit();
    return .disarm;
}

/// Callback for accepting new connections
fn acceptCallback(
    userdata: ?*Server,
    loop: *xev.Loop,
    completion: *xev.Completion,
    result: xev.AcceptError!xev.TCP,
) xev.CallbackAction {
    _ = completion;
    const server = userdata.?;

    const client_tcp = result catch |err| {
        log.err("Failed to accept connection: {any}", .{err});
        return .rearm;
    };

    // Check if connection pool is full
    if (!server.connection_pool.tryAcquire()) {
        log.warn("‚ö†Ô∏è  Connection pool full, rejecting connection. Active: {}", .{server.connection_pool.getActiveCount()});
        return .rearm;
    }

    log.info("üì• Accepted new connection (Active: {})", .{server.connection_pool.getActiveCount()});

    // Create client connection
    const client_conn = server.allocator.create(ClientConnection) catch |err| {
        log.err("Failed to allocate client connection: {any}", .{err});
        server.connection_pool.release();
        return .rearm;
    };

    client_conn.* = ClientConnection.init(client_tcp, server, server.allocator);

    // Start reading HTTP request
    // Use client_conn.read_completion
    client_tcp.read(loop, &client_conn.read_completion, .{ .slice = &client_conn.buffer }, ClientConnection, client_conn, readCallback);

    return .rearm;
}

/// Callback for reading HTTP request data
fn readCallback(
    userdata: ?*ClientConnection,
    loop: *xev.Loop,
    completion: *xev.Completion,
    tcp: xev.TCP,
    buffer: xev.ReadBuffer,
    result: xev.ReadError!usize,
) xev.CallbackAction {
    _ = completion;
    _ = tcp;
    _ = buffer;
    const client_conn = userdata.?;

    const bytes_read = result catch |err| {
        log.err("Failed to read from connection: {any}", .{err});
        client_conn.close(loop);
        return .disarm;
    };

    if (bytes_read == 0) {
        log.info("üì§ Connection closed by client", .{});
        client_conn.close(loop);
        return .disarm;
    }

    // Update timing information
    client_conn.timing.updateReadTime();
    client_conn.total_read += bytes_read;

    // Check for timeouts and slow attacks
    if (client_conn.checkTimeouts()) {
        log.warn("üö´ Closing connection due to timeout or slow attack", .{});
        client_conn.close(loop);
        return .disarm;
    }

    // Check for reasonable request size limits - allow for large bodies but prevent abuse
    const max_reasonable_request = client_conn.server.config.max_body_size + 64 * 1024; // body + 64KB for headers
    if (client_conn.total_read > max_reasonable_request) {
        log.warn("üö´ Request too large: {} bytes (limit: {} bytes)", .{ client_conn.total_read, max_reasonable_request });
        sendErrorResponse(client_conn, loop, .payload_too_large) catch {};
        return .disarm;
    }

    log.info("üì® Received {} bytes (total: {})", .{ bytes_read, client_conn.total_read });

    // Append data to request buffer
    client_conn.request_buffer.appendSlice(client_conn.buffer[0..bytes_read]) catch |err| {
        log.err("Failed to append to request buffer: {any}", .{err});
        sendErrorResponse(client_conn, loop, .internal_server_error) catch {};
        return .disarm;
    };

    // Check if we have complete headers
    if (!client_conn.timing.headers_complete) {
        if (std.mem.indexOf(u8, client_conn.request_buffer.items, "\r\n\r\n")) |_| {
            // Parse Content-Length if present
            const content_length = security.parseContentLength(client_conn.request_buffer.items);
            client_conn.timing.setHeadersComplete(content_length);
        }
    }

    // Update body length tracking
    if (client_conn.timing.headers_complete) {
        const header_end = std.mem.indexOf(u8, client_conn.request_buffer.items, "\r\n\r\n");
        const body_length = if (header_end) |end_pos|
            client_conn.request_buffer.items.len - (end_pos + 4)
        else
            0;
        client_conn.timing.updateBodyLength(body_length);
    }

    // Try to process the request if we have enough data
    const should_process = blk: {
        if (!client_conn.timing.headers_complete) {
            break :blk false; // Need complete headers
        }

        if (client_conn.timing.expected_body_length) |expected| {
            break :blk client_conn.timing.received_body_length >= expected; // Need complete body
        }

        break :blk true; // No body expected, headers are enough
    };

    if (should_process) {
        // Process the complete HTTP request
        processHttpRequestFromBuffer(client_conn, loop) catch |err| {
            log.err("Failed to process HTTP request: {any}", .{err});
            sendErrorResponse(client_conn, loop, .internal_server_error) catch {};
        };
        return .disarm;
    } else {
        // Continue reading more data
        client_conn.tcp.read(loop, &client_conn.read_completion, .{ .slice = &client_conn.buffer }, ClientConnection, client_conn, readCallback);
        return .disarm;
    }
}

/// Process HTTP request from accumulated buffer and send response
fn processHttpRequestFromBuffer(client_conn: *ClientConnection, loop: *xev.Loop) !void {
    const request_data = client_conn.request_buffer.items;

    // Parse HTTP request
    var request = HttpRequest.parseFromBuffer(client_conn.allocator, request_data, client_conn.server.config) catch |err| {
        log.err("Failed to parse HTTP request: {any}", .{err});
        try sendErrorResponse(client_conn, loop, .bad_request);
        return;
    };
    defer request.deinit();

    log.info("üìã Processing {any} {s}", .{ request.method, request.path });

    // Create HTTP response
    var response = HttpResponse.init(client_conn.allocator);
    defer response.deinit();

    // Create context
    var ctx = Context.init(client_conn.allocator, &request, &response);
    defer ctx.deinit();

    // Handle request with router
    client_conn.server.router.handleRequest(&ctx) catch |err| {
        log.err("Router error: {any}", .{err});
        switch (err) {
            error.NotFound => {
                ctx.status(.not_found);
                try ctx.json("{\"error\":\"Not Found\",\"message\":\"The requested resource was not found\"}");
            },
            error.InvalidMethod => {
                ctx.status(.method_not_allowed);
                try ctx.json("{\"error\":\"Method Not Allowed\",\"message\":\"The HTTP method is not supported\"}");
            },
            else => {
                ctx.status(.internal_server_error);
                try ctx.json("{\"error\":\"Internal Server Error\",\"message\":\"An unexpected error occurred\"}");
            },
        }
    };

    // Build and send response
    const response_data = try response.build();

    log.info("üì§ Sending {} bytes response", .{response_data.len});
    try sendResponse(client_conn, loop, response_data);
}

/// Process HTTP request and send response (legacy function for compatibility)
fn processHttpRequest(client_conn: *ClientConnection, loop: *xev.Loop) !void {
    // For legacy compatibility, copy buffer data to request_buffer and process
    try client_conn.request_buffer.appendSlice(client_conn.buffer[0..client_conn.read_len]);
    return processHttpRequestFromBuffer(client_conn, loop);
}

/// Send HTTP response to client
fn sendResponse(client_conn: *ClientConnection, loop: *xev.Loop, response_data: []u8) !void {
    // Use client_conn.write_completion
    // Store response_data in ClientConnection to keep it alive
    client_conn.response_data = response_data;
    client_conn.tcp.write(loop, &client_conn.write_completion, .{ .slice = response_data }, ClientConnection, client_conn, writeCallback);

    // Run one iteration to complete the write
}

/// Callback for writing response data
fn writeCallback(
    userdata: ?*ClientConnection,
    loop: *xev.Loop,
    completion: *xev.Completion,
    tcp: xev.TCP,
    buffer: xev.WriteBuffer,
    result: xev.WriteError!usize,
) xev.CallbackAction {
    _ = completion;
    _ = tcp;
    _ = buffer;
    const client_conn = userdata.?;

    const bytes_written = result catch |err| {
        log.err("Failed to write response: {any}", .{err});
        client_conn.close(loop);
        return .disarm;
    };

    log.info("‚úÖ Sent {} bytes response", .{bytes_written});

    // Close connection after sending response
    client_conn.close(loop);
    return .disarm;
}

/// Send error response to client
fn sendErrorResponse(client_conn: *ClientConnection, loop: *xev.Loop, status: StatusCode) !void {
    var response = HttpResponse.init(client_conn.allocator);
    defer response.deinit();

    response.status = status;
    try response.setHeader("Content-Type", "application/json");
    try response.setHeader("Connection", "close");

    const error_json = try std.fmt.allocPrint(client_conn.allocator, "{{\"error\":\"{s}\",\"code\":{}}}", .{ status.toString(), @intFromEnum(status) });
    defer client_conn.allocator.free(error_json);

    try response.setBody(error_json);

    const response_data = try response.build();

    try sendResponse(client_conn, loop, response_data);
}

/// Create a new HTTP server
pub fn createServer(allocator: Allocator, host: []const u8, port: u16) !Server {
    return try Server.init(allocator, host, port);
}

/// Create a new HTTP server with custom max connections
pub fn createServerWithMaxConnections(allocator: Allocator, host: []const u8, port: u16, max_connections: u32) !Server {
    return try Server.initWithMaxConnections(allocator, host, port, max_connections);
}

/// Create a new HTTP server with custom configuration
pub fn createServerWithConfig(allocator: Allocator, host: []const u8, port: u16, config: HttpConfig) !Server {
    return try Server.initWithConfig(allocator, host, port, config);
}

// Tests
test "library exports" {
    const testing = std.testing;
    try testing.expect(version_major == 1);
    try testing.expect(version_minor == 0);
    try testing.expect(version_patch == 0);
    try testing.expectEqualStrings("1.0.0", version);
}

test "server creation and routes" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var server = try createServer(allocator, "127.0.0.1", 8080);
    defer server.deinit();

    try testing.expectEqualStrings("127.0.0.1", server.host);
    try testing.expect(server.port == 8080);

    // Test adding routes
    const testHandler = struct {
        fn handler(ctx: *Context) !void {
            _ = ctx;
        }
    }.handler;

    _ = try server.get("/", testHandler);
    _ = try server.post("/api/users", testHandler);

    try testing.expect(server.router.routes.items.len == 2);
}

test "module integration" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Test request parsing
    const raw_request = "GET /hello HTTP/1.1\r\nHost: localhost\r\n\r\n";
    const config = HttpConfig{};
    var request = try HttpRequest.parseFromBuffer(allocator, raw_request, config);
    defer request.deinit();

    // Test response building
    var response = HttpResponse.init(allocator);
    defer response.deinit();

    // Test context
    var ctx = Context.init(allocator, &request, &response);
    defer ctx.deinit();

    try ctx.json("{\"message\":\"test\"}");

    try testing.expectEqualStrings("GET", request.method);
    try testing.expectEqualStrings("/hello", request.path);
    try testing.expect(response.body != null);
}

```

Excellent! Let's move from the "recipe book" (`build.zig`) to the "main kitchen" itself. This file, `lib.zig`, is the heart of our web server library. It's where all the core components are assembled and managed.

---

### Welcome, Class! Inside the Engine Room: `lib.zig`

Yesterday, we looked at the `build.zig` file, which was our recipe book for compiling the project. Today, we're stepping into the main factory, the engine room where all the work happens: `lib.zig`.

This file has two primary jobs:
1.  **It defines the main `Server` and how it handles connections.** This is the core logic.
2.  **It acts as the main "front door" or "lobby" for our entire library.** It gathers all the important pieces from other files (`request.zig`, `response.zig`, etc.) and presents them in one convenient place for the person using our library.

Let's start at the top.

---

### Part 1: The Library's "Lobby" (Imports & Re-exports)

```zig
//! libxev-http: High-performance async HTTP framework for Zig
//! ... (documentation comments)

const std = @import("std");
const xev = @import("xev");
// ... other imports

// Version information
pub const version = "1.0.0";
// ...

// Re-export commonly used types
pub const Allocator = std.mem.Allocator;
// ...

// Re-export core modules
pub const HttpRequest = @import("request.zig").HttpRequest;
pub const HttpResponse = @import("response.zig").HttpResponse;
// ... (many more re-exports)
```

The first thing you'll notice after the initial documentation comments (`//!`) is a huge block of `pub const ...` lines. This is a very important and friendly design pattern in Zig.

Think of our library as a large company building with many different departments on different floors (e.g., the `request.zig` file is the "Incoming Mail Department," `response.zig` is the "Outgoing Mail Department").

Instead of making a visitor (the programmer using our library) run around to all these different files to get what they need, we've created a **central lobby** right here in `lib.zig`.

These `pub const` lines are like a directory in the lobby. We're saying:
*   "Looking for `HttpRequest`? You don't have to know it's in `request.zig`. You can just get it right here from the main library."
*   "Need a `Router`? It's right here."
*   "Looking for some built-in `loggingMiddleware`? We've brought it out to the front for you."

This is called **re-exporting**. It makes our library much cleaner and easier to use. The user only needs to `@import` this one file to get access to all the most important tools.

---

### Part 2: The Core Components (Structs)

Now we get to the main machinery. There are three key data structures, or `struct`s, that work together. Let's use an analogy of a busy restaurant.

#### `ClientConnection`: The Waiter

```zig
const ClientConnection = struct {
    tcp: xev.TCP,
    server: *Server,
    allocator: Allocator,
    buffer: [8192]u8,
    // ... other fields
};
```
This struct represents **one single client** connected to our server. Think of this as a **waiter** assigned to a specific table.

*   `tcp: xev.TCP`: This is the direct phone line to the customer (the TCP connection).
*   `server: *Server`: A reference back to the "Restaurant Manager" so the waiter knows who they work for.
*   `allocator: Allocator`: The waiter's budget for things like taking notes or preparing the bill.
*   `buffer`: The waiter's notepad, where they write down the customer's order as it comes in.
*   `timing`: A stopwatch to make sure a customer doesn't take forever to order (this prevents certain types of attacks).
*   `init()` and `deinit()`: These functions are like the waiter setting up the table for a new customer and clearing it after they leave.

#### `ConnectionPool`: The Host/Hostess

```zig
const ConnectionPool = struct {
    active_connections: std.atomic.Value(u32),
    max_connections: u32,
};
```
This struct's job is to make sure our restaurant doesn't get overcrowded. It's the **host or hostess** at the front door.

*   `max_connections`: The fire code limit for our restaurant. We can't have more customers than this.
*   `active_connections`: The current number of customers in the restaurant. (It's `atomic` which is a special type that ensures this count is accurate even when many waiters try to update it at the exact same time).
*   `tryAcquire()`: This is like asking the hostess, "Is there a free table?" It returns `true` if yes, `false` if the restaurant is full.
*   `release()`: This is the waiter telling the hostess, "My table is free now!"

#### `Server`: The Restaurant Manager

```zig
pub const Server = struct {
    allocator: Allocator,
    host: []const u8,
    port: u16,
    router: *Router,
    connection_pool: ConnectionPool,
    config: HttpConfig,
};
```
This is the big boss, the **Restaurant Manager**. It holds everything together.

*   `host` and `port`: The restaurant's address.
*   `router`: The **menu**. This is the component that knows what to do for each request (e.g., if a customer asks for `/users`, the router knows to call the "get users" chef).
*   `connection_pool`: The manager's connection to the hostess at the front door.
*   `get()`, `post()`, `use()`: These are methods the owner uses to tell the manager to add new items to the menu (the router).
*   `listen()`: This is the most important function. It's the manager shouting, **"We're open for business!"** and starting the whole process.

---

### Part 3: The Asynchronous Magic (Callbacks)

This is the most important concept to understand. Our server is **asynchronous** or **event-driven**.

A *synchronous* restaurant would have the manager constantly running to the front door shouting "ANYONE THERE YET? ANYONE THERE YET?". This is very inefficient.

Our *asynchronous* restaurant works with a system of bells.
1.  The manager tells the front door: "Ring a bell when a customer arrives." (`tcp_server.accept`)
2.  The manager goes off and does other things.
3.  When a customer arrives, a bell rings, and a special function called a **callback** is automatically run.

Let's follow the lifecycle of one request:

#### Step 1: `acceptCallback`
*   **The Event:** A new customer walks in the door. The `accept` bell rings!
*   **The Action:** The `acceptCallback` function runs.
    *   It first asks the `connection_pool` (the hostess), "Do we have a free table?"
    *   If yes, it creates a new `ClientConnection` (assigns a new waiter to the table).
    *   It then tells the new waiter, "Ring a bell for me as soon as this customer starts speaking." (`client_tcp.read`).

#### Step 2: `readCallback`
*   **The Event:** The customer starts giving their order (sends HTTP request data). The `read` bell rings!
*   **The Action:** The `readCallback` function runs for that specific `ClientConnection` (waiter).
    *   It writes down what the customer said into its `buffer` (notepad).
    *   It checks, "Is this the full order, or are they still talking?" It looks for the special `\r\n\r\n` sequence that marks the end of the HTTP headers.
    *   If the order isn't complete, it just says, "Okay, keep listening."
    *   If the order *is* complete, it calls `processHttpRequestFromBuffer` to send the order to the kitchen.

#### Step 3: `processHttpRequestFromBuffer` (The Kitchen)
*   This isn't a callback, but it's the next step.
*   It takes the raw text from the waiter's notepad.
*   It parses it into a structured `HttpRequest` object.
*   It looks at the request path (e.g., `/users`) and gives it to the `router` (the menu).
*   The router finds the correct chef (`HandlerFn`) to handle this specific dish.
*   The chef prepares the meal and puts it into an `HttpResponse` object.
*   Finally, it tells a waiter to deliver the food by calling `sendResponse`.

#### Step 4: `writeCallback`
*   **The Event:** The waiter has successfully delivered the food to the customer. The `write` bell rings!
*   **The Action:** The `writeCallback` function runs.
    *   It logs that the response was sent successfully.
    *   Since the transaction is complete, it tells the customer's connection to close (`client_conn.close`).

#### Step 5: `closeCallback`
*   **The Event:** The connection has been fully closed. The `close` bell rings!
*   **The Action:** The `closeCallback` function runs.
    *   It cleans up everything associated with that waiter and table (`client_conn.deinit()`).
    *   Crucially, the waiter also tells the hostess their table is now free (`self.server.connection_pool.release()`, which happens inside the `close` function).

---

### Part 4: The Self-Checks (Tests)

```zig
test "library exports" { ... }
test "server creation and routes" { ... }
test "module integration" { ... }
```
At the very bottom of the file, you see `test` blocks. These are built-in checks to make sure our kitchen is working correctly.
*   `test "server creation and routes"` is like checking that the manager can correctly add items to the menu.
*   `test "module integration"` is a quick check to ensure the whole process‚Äîfrom taking an order to preparing a response‚Äîworks on a small scale.

### Conclusion

This `lib.zig` file is the heart of the server. It uses a series of structs to manage the server's state and an asynchronous, event-driven model with callbacks to handle many connections efficiently without getting stuck waiting for any single one. It's like a well-run restaurant where the staff doesn't stand around waiting, but instead responds instantly when a bell rings, signaling that their attention is needed.


Â•ΩÁöÑÔºåÊàë‰ª¨Êù•ÊâÆÊºîËÄÅÂ∏àÂíåÂ≠¶ÁîüÔºå‰∏ÄËµ∑Ê∑±ÂÖ•Á†îÁ©∂Ëøô‰∏™ `lib.zig` Êñá‰ª∂„ÄÇËøô‰∏™Êñá‰ª∂ÊòØÊï¥‰∏™ Web Ê°ÜÊû∂ÁöÑÂøÉËÑèÔºåÊâÄÊúâÁöÑÊ†∏ÂøÉÈÄªËæëÈÉΩÂú®ËøôÈáå„ÄÇ

---

### ÂêÑ‰ΩçÂêåÂ≠¶ÔºåÊ¨¢ËøéÊù•Âà∞ÂºïÊìéÂÆ§Ôºö`lib.zig` Êñá‰ª∂ËØ¶Ëß£

Êò®Â§©Êàë‰ª¨Â≠¶‰π†‰∫Ü `build.zig`ÔºåÈÇ£ÊòØÊàë‰ª¨È°πÁõÆÁöÑ‚ÄúËèúË∞±‚Äù„ÄÇ‰ªäÂ§©ÔºåÊàë‰ª¨Ë¶ÅËµ∞ËøõÁúüÊ≠£ÁöÑ‚ÄúÂé®Êàø‚ÄùÊàñËÄÖËØ¥‚ÄúÂºïÊìéÂÆ§‚Äù‚Äî‚Äî`lib.zig` Êñá‰ª∂„ÄÇ

Ëøô‰∏™Êñá‰ª∂‰∏ªË¶ÅÊúâ‰∏§‰∏™ËÅåË¥£Ôºö

1.  **ÂÆö‰πâÊ†∏ÂøÉÁöÑ `Server`ÔºàÊúçÂä°Âô®Ôºâ‰ª•ÂèäÂÆÉÂ¶Ç‰ΩïÂ§ÑÁêÜÁΩëÁªúËøûÊé•„ÄÇ** ËøôÊòØÊúÄÂÖ≥ÈîÆÁöÑËøêË°åÈÄªËæë„ÄÇ
2.  **ÂÖÖÂΩìÊï¥‰∏™Â∫ìÁöÑ‚ÄúÂ§ßÈó®‚ÄùÊàñ‚ÄúÂâçÂè∞‚Äù„ÄÇ** ÂÆÉÊääÂÖ∂‰ªñÊñá‰ª∂ÔºàÂ¶Ç `request.zig`, `response.zig`Ôºâ‰∏≠ÊúÄÈáçË¶ÅÁöÑÈÉ®ÂàÜÈõÜ‰∏≠Ëµ∑Êù•ÔºåÊñπ‰æø‰ΩøÁî®Ëøô‰∏™Â∫ìÁöÑÁ®ãÂ∫èÂëòË∞ÉÁî®„ÄÇ

Êàë‰ª¨‰ªéÂ§¥ÂºÄÂßãÁúã„ÄÇ

---

### Á¨¨‰∏ÄÈÉ®ÂàÜÔºöÂ∫ìÁöÑ‚ÄúÂâçÂè∞Â§ßÂéÖ‚ÄùÔºàÂØºÂÖ•‰∏éÈáçÂØºÂá∫Ôºâ

```zig
//! libxev-http: High-performance async HTTP framework for Zig
//! ... (Ëøô‰∫õÊòØÊñáÊ°£Ê≥®Èáä)

const std = @import("std");
const xev = @import("xev");
// ... ÂÖ∂‰ªñÂØºÂÖ•

// Version information
pub const version = "1.0.0";
// ...

// Re-export commonly used types (ÈáçÂØºÂá∫Â∏∏Áî®Á±ªÂûã)
pub const Allocator = std.mem.Allocator;
// ...

// Re-export core modules (ÈáçÂØºÂá∫Ê†∏ÂøÉÊ®°Âùó)
pub const HttpRequest = @import("request.zig").HttpRequest;
pub const HttpResponse = @import("response.zig").HttpResponse;
// ... (ÂêéÈù¢ËøòÊúâÂæàÂ§öÁ±ª‰ººÁöÑË°å)
```

Âú®Êñá‰ª∂ÁöÑÂºÄÂ§¥Ôºå‰Ω†‰ºöÁúãÂà∞‰∏ÄÂ§ßÁâá `pub const ...`„ÄÇËøôÊòØ‰∏Ä‰∏™Âú® Zig ‰∏≠ÈùûÂ∏∏ÂèãÂ•Ω‰∏îÈáçË¶ÅÁöÑËÆæËÆ°Ê®°ÂºèÔºåÊàë‰ª¨Áß∞‰πã‰∏∫ **‚ÄúÈáçÂØºÂá∫‚ÄùÔºàRe-exportingÔºâ**„ÄÇ

ÊÉ≥Ë±°‰∏Ä‰∏ãÊàë‰ª¨ÁöÑÂ∫ìÊòØ‰∏Ä‰∏™ÊúâÂ§öÂ±ÇÂ§öÈÉ®Èó®ÁöÑÂ§ßÂÖ¨Âè∏ÔºàÊØîÂ¶Ç `request.zig` ÊòØ‚ÄúÊî∂ÂèëÂÆ§‚ÄùÔºå`response.zig` ÊòØ‚ÄúÂ§ñËÅîÈÉ®‚ÄùÔºâ„ÄÇ

Êàë‰ª¨‰∏çÂ∏åÊúõ‰∏Ä‰∏™ËÆøÂÆ¢Ôºà‰πüÂ∞±ÊòØ‰ΩøÁî®Êàë‰ª¨Â∫ìÁöÑÁ®ãÂ∫èÂëòÔºâ‰∏∫‰∫ÜÊâæ‰∏çÂêåÁöÑÂ∑•ÂÖ∑ËÄåË∑ëÈÅçÊâÄÊúâÈÉ®Èó®„ÄÇÊâÄ‰ª•ÔºåÊàë‰ª¨Âú®Ëøô‰∏™ `lib.zig` Êñá‰ª∂ÈáåÂª∫Á´ã‰∫Ü‰∏Ä‰∏™ **‚Äú‰∏≠Â§ÆÂâçÂè∞‚Äù**„ÄÇ

Ëøô‰∫õ `pub const` Ë°åÂ∞±ÂÉèÊòØÂâçÂè∞ÁöÑÊåáÁ§∫ÁâåÔºö
*   ‚ÄúÊÉ≥Êâæ `HttpRequest` ÂêóÔºü‰Ω†‰∏çÁî®Âéª `request.zig` Êñá‰ª∂ÈáåÊâæÔºåÁõ¥Êé•‰ªéÊàëËøôÈáåÔºà`lib.zig`ÔºâÊãøÂ∞±Ë°å„ÄÇ‚Äù
*   ‚ÄúÈúÄË¶Å `Router` ÂêóÔºüÁªô‰Ω†ÔºåÂú®ËøôÈáå„ÄÇ‚Äù

ËøôÊ†∑ÂÅöËÆ©Êàë‰ª¨ÁöÑÂ∫ìÂØπ‰ΩøÁî®ËÄÖÊù•ËØ¥ÈùûÂ∏∏Âπ≤ÂáÄ„ÄÅÊñπ‰æø„ÄÇÁî®Êà∑Âè™ÈúÄË¶Å `@import` Ëøô‰∏Ä‰∏™ `lib.zig` Êñá‰ª∂ÔºåÂ∞±ËÉΩËé∑ÂæóÊâÄÊúâÊúÄÊ†∏ÂøÉÁöÑÂ∑•ÂÖ∑„ÄÇ

---

### Á¨¨‰∫åÈÉ®ÂàÜÔºöÊ†∏ÂøÉÁªÑ‰ª∂ÔºàStruct ÁªìÊûÑ‰ΩìÔºâ

Áé∞Âú®Êàë‰ª¨Êù•ÁúãÁúãÈ©±Âä®ÊúçÂä°Âô®ËøêËΩ¨ÁöÑÊ†∏ÂøÉÊú∫Ê¢∞„ÄÇËøôÈáåÊúâ‰∏â‰∏™ÂÖ≥ÈîÆÁöÑÁªìÊûÑ‰ΩìÔºåÊàë‰ª¨ÂèØ‰ª•Áî®‰∏Ä‰∏™**ÁπÅÂøôÁöÑÈ§êÂéÖ**Êù•ÊØîÂñªÂÆÉ‰ª¨„ÄÇ

#### 1. `ClientConnection`ÔºöÊúçÂä°Âëò

```zig
const ClientConnection = struct {
    tcp: xev.TCP,
    server: *Server,
    allocator: Allocator,
    buffer: [8192]u8,
    // ... ÂÖ∂‰ªñÂ≠óÊÆµ
};
```

Ëøô‰∏™ÁªìÊûÑ‰Ωì‰ª£Ë°®**‰∏Ä‰∏™ËøûÊé•Âà∞ÊúçÂä°Âô®ÁöÑÁã¨Á´ãÂÆ¢Êà∑Á´Ø**„ÄÇ‰Ω†ÂèØ‰ª•ÊääÂÆÉÊÉ≥Ë±°Êàê‰∏Ä‰∏™**Ë¢´ÊåáÊ¥æÂà∞ÁâπÂÆöÈ§êÊ°åÁöÑ‚ÄúÊúçÂä°Âëò‚Äù**„ÄÇ

*   `tcp: xev.TCP`: ËøôÊòØ‰∏éÈ°æÂÆ¢ÁöÑ**Áõ¥Êé•ÁîµËØùÁ∫ø**ÔºàTCP ËøûÊé•Ôºâ„ÄÇ
*   `server: *Server`: ÊåáÂêë‚ÄúÈ§êÂéÖÁªèÁêÜ‚ÄùÔºåËøôÊ†∑ÊúçÂä°ÂëòÊâçÁü•ÈÅì‰∏∫Ë∞ÅÂ∑•‰Ωú„ÄÇ
*   `allocator: Allocator`: ÊúçÂä°ÂëòÁöÑ‚ÄúÁªèË¥π‚ÄùÔºåÁî®Êù•ËÆ∞ÂΩïÁÇπÂçï„ÄÅÂáÜÂ§áË¥¶ÂçïÁ≠âÈúÄË¶ÅÂÜÖÂ≠òÁöÑÊìç‰Ωú„ÄÇ
*   `buffer`: ÊúçÂä°ÂëòÁöÑ**ÁÇπÈ§êÊú¨**ÔºåÁî®Êù•ËÆ∞ÂΩïÈ°æÂÆ¢ËØ¥ÁöÑÊØè‰∏ÄÂè•ËØùÔºàËØ∑Ê±ÇÊï∞ÊçÆÔºâ„ÄÇ
*   `timing`: ‰∏Ä‰∏™ÁßíË°®ÔºåÁ°Æ‰øùÈ°æÂÆ¢‰∏ç‰ºöÁÇπ‰∏Ä‰∏™ËèúÁÇπÂçäÂ§©ÔºàËøôÂèØ‰ª•Èò≤Ê≠¢ÊÖ¢ÈÄüÊîªÂáªÔºâ„ÄÇ

#### 2. `ConnectionPool`ÔºöÈ§êÂéÖÈ¢Ü‰ΩçÂëò

```zig
const ConnectionPool = struct {
    active_connections: std.atomic.Value(u32),
    max_connections: u32,
};
```

Ëøô‰∏™ÁªìÊûÑ‰ΩìÁöÑÂîØ‰∏ÄÂ∑•‰ΩúÂ∞±ÊòØ**Á°Æ‰øùÈ§êÂéÖ‰∏ç‰ºö‰∫∫Êª°‰∏∫ÊÇ£**„ÄÇÂÆÉÂ∞±ÂÉèÊòØÁ´ôÂú®Èó®Âè£ÁöÑ**‚ÄúÈ¢Ü‰ΩçÂëò‚Äù**„ÄÇ

*   `max_connections`: È§êÂéÖÁöÑÊ∂àÈò≤ËßÑÂÆö‰∫∫Êï∞‰∏äÈôê„ÄÇ
*   `active_connections`: ÂΩìÂâçÂú®È§êÂéÖÈáåÁöÑÂÆ¢‰∫∫Êï∞Èáè„ÄÇÂÆÉÊòØ‰∏Ä‰∏™ `atomic`ÔºàÂéüÂ≠êÔºâÁ±ªÂûãÔºåÁ°Æ‰øùÂç≥‰ΩøÂæàÂ§öÊúçÂä°ÂëòÂêåÊó∂Êõ¥Êñ∞Ëøô‰∏™Êï∞Â≠óÔºåÂÆÉ‰πüÊÄªÊòØÂáÜÁ°ÆÁöÑ„ÄÇ
*   `tryAcquire()`: Áõ∏ÂΩì‰∫éÈóÆÈ¢Ü‰ΩçÂëòÔºö‚ÄúËøòÊúâÁ©∫Ê°åÂêóÔºü‚Äù Â¶ÇÊûúÊúâÔºåËøîÂõû `true`ÔºõÂ¶ÇÊûúÊª°‰∫ÜÔºåËøîÂõû `false`„ÄÇ
*   `release()`: ÊúçÂä°ÂëòÂëäËØâÈ¢Ü‰ΩçÂëòÔºö‚ÄúÊàëËøôÊ°åÂÆ¢‰∫∫Ëµ∞‰∫ÜÔºÅ‚Äù

#### 3. `Server`ÔºöÈ§êÂéÖÁªèÁêÜ

```zig
pub const Server = struct {
    // ...
    router: *Router,
    connection_pool: ConnectionPool,
    // ...
};
```
ËøôÊòØÊÄªÊåáÊå•‚Äî‚Äî**‚ÄúÈ§êÂéÖÁªèÁêÜ‚Äù**„ÄÇÂÆÉÊääÊâÄÊúâÈÉ®ÂàÜÁªÑÁªáÂú®‰∏ÄËµ∑„ÄÇ

*   `router`: È§êÂéÖÁöÑ**ËèúÂçï**„ÄÇÂÆÉÁü•ÈÅìÊØè‰∏™ËØ∑Ê±ÇËØ•Â¶Ç‰ΩïÂ§ÑÁêÜÔºà‰æãÂ¶ÇÔºåÈ°æÂÆ¢ÁÇπ `/users`ÔºåËèúÂçïÁü•ÈÅìËØ•ÊâæÂì™‰∏™Âé®Â∏àÔºâ„ÄÇ
*   `connection_pool`: ÁªèÁêÜÂíåÈó®Âè£È¢Ü‰ΩçÂëòÁöÑËÅîÁ≥ªÊñπÂºè„ÄÇ
*   `listen()`: ËøôÊòØÊúÄÈáçË¶ÅÁöÑÊñπÊ≥ï„ÄÇÂÆÉÁõ∏ÂΩì‰∫éÁªèÁêÜÂ§ßÂñä‰∏ÄÂ£∞Ôºö**‚ÄúÂºÄÈó®Ëê•‰∏öÔºÅ‚Äù**ÔºåÁÑ∂ÂêéÊï¥‰∏™È§êÂéÖÂ∞±ÂºÄÂßãËøê‰Ωú‰∫Ü„ÄÇ

---

### Á¨¨‰∏âÈÉ®ÂàÜÔºöÂºÇÊ≠•ÁöÑÈ≠îÊ≥ïÔºàÂõûË∞ÉÂáΩÊï∞‰∏é xevÔºâ

ËøôÊòØÊúÄÊ†∏ÂøÉ„ÄÅ‰πüÊúÄÈúÄË¶ÅÁêÜËß£ÁöÑÈÉ®ÂàÜ„ÄÇÊàë‰ª¨ÁöÑÊúçÂä°Âô®ÊòØ**ÂºÇÊ≠•ÁöÑÔºàasynchronousÔºâ**ÔºåÊàñËÄÖÂè´**‰∫ã‰ª∂È©±Âä®ÁöÑÔºàevent-drivenÔºâ**„ÄÇ

‰∏Ä‰∏™**ÂêåÊ≠•**ÁöÑÈ§êÂéÖÁªèÁêÜ‰ºö‰∏çÂÅúÂú∞Ë∑ëÂà∞Èó®Âè£ÂñäÔºö‚ÄúÊù•ÂÆ¢‰∫∫‰∫ÜÂêóÔºüÊù•ÂÆ¢‰∫∫‰∫ÜÂêóÔºü‚Äù ËøôÈùûÂ∏∏‰ΩéÊïà„ÄÇ

Êàë‰ª¨ÁöÑ**ÂºÇÊ≠•**È§êÂéÖÁªèÁêÜÂàô‰ΩøÁî®‰∏ÄÂ•ó**‚ÄúÈìÉÈìõÁ≥ªÁªü‚Äù**„ÄÇ

1.  ÁªèÁêÜÂëäËØâÈó®Âè£Ôºö‚ÄúÊúâÂÆ¢‰∫∫Êù•ÁöÑÊó∂ÂÄôÔºå**Êëá‰∏Ä‰∏ãÈìÉÈìõ**„ÄÇ‚Äù
2.  ÁÑ∂ÂêéÁªèÁêÜÂ∞±ÂéªÂøôÂà´ÁöÑ‰∫ã‰∫Ü„ÄÇ
3.  ÂΩìÂÆ¢‰∫∫ÁúüÁöÑÊù•‰∫ÜÔºåÈìÉÈìõÂìçËµ∑Ôºå‰∏Ä‰∏™ÁâπÊÆäÁöÑÂáΩÊï∞‚Äî‚ÄîÊàë‰ª¨Áß∞‰πã‰∏∫**ÂõûË∞ÉÂáΩÊï∞ÔºàCallbackÔºâ**‚Äî‚ÄîÂ∞±‰ºöË¢´Ëá™Âä®ÊâßË°å„ÄÇ

ËøôÈáåÁöÑ `xev` Â∫ìÂ∞±ÊòØ‰∏∫Êàë‰ª¨Êèê‰æõËøôÂ•ó‚ÄúÈìÉÈìõÁ≥ªÁªü‚ÄùÁöÑ„ÄÇËÆ©Êàë‰ª¨Ë∑üË∏™‰∏Ä‰∏™ËØ∑Ê±ÇÁöÑÂÆåÊï¥ÁîüÂëΩÂë®ÊúüÔºåÂπ∂ÈáçÁÇπÂÖ≥Ê≥® `xev` ÁöÑË∞ÉÁî®„ÄÇ

#### `listen()` ÂáΩÊï∞ÔºöÂºÄÈó®Ëê•‰∏ö

```zig
pub fn listen(self: *Server) !void {
    // ... ÁúÅÁï•Êó•ÂøóÊâìÂç∞ ...

    var loop = try xev.Loop.init(...); // 1. ÂáÜÂ§áÂ•Ω‰∫ã‰ª∂Âæ™ÁéØÔºà‚ÄúÁªèÁêÜÁöÑÂ§ßËÑë‚ÄùÔºâ
    defer loop.deinit();

    var tcp_server = try xev.TCP.init(address); // 2. ÂáÜÂ§áÂ•ΩTCPÊúçÂä°Âô®Ôºà‚ÄúÈ§êÂéÖÂ§ßÈó®‚ÄùÔºâ
    try tcp_server.bind(address);
    try tcp_server.listen(128); // 3. ÂºÄÂßãÁõëÂê¨Ôºà‚ÄúÊääÈó®ÊâìÂºÄ‚ÄùÔºâ

    // ...

    var accept_completion: xev.Completion = .{};
    tcp_server.accept(&loop, &accept_completion, Server, self, acceptCallback); // 4. ËÆæÁΩÆÈìÉÈìõ

    try loop.run(.until_done); // 5. ÂºÄÂßãÂ∑•‰ΩúÔºÅÔºà‚ÄúÁªèÁêÜÂºÄÂßãÂê¨ÊâÄÊúâÈìÉÈìõÁöÑÂ£∞Èü≥‚ÄùÔºâ
}
```

Á¨¨4Ê≠•ÊòØÁ¨¨‰∏Ä‰∏™ÂÖ≥ÈîÆÁöÑ `xev` Ë∞ÉÁî®Ôºö
*   `tcp_server.accept(...)`: ËøôÂè•ËØùÁöÑÊÑèÊÄùÊòØÔºö‚ÄúÂòøÔºå`xev`ÔºåËØ∑Â∏ÆÊàëÁõëÂê¨ `tcp_server` Ëøô‰∏™Â§ßÈó®„ÄÇ‚Äù
*   `&loop`: Âú®Âì™‰∏™‰∫ã‰ª∂Âæ™ÁéØ‰∏äÁõëÂê¨„ÄÇ
*   `Server, self, acceptCallback`: **ËøôÊòØÈ≠îÊ≥ïÁöÑÊ†∏ÂøÉÔºÅ** ÂÆÉÂëäËØâ `xev`Ôºö‚ÄúÂΩì‰∏Ä‰∏™Êñ∞ËøûÊé•Âà∞Êù•Êó∂Ôºà‰∫ã‰ª∂ÂèëÁîüÊó∂ÔºâÔºåËØ∑Ë∞ÉÁî® `acceptCallback` Ëøô‰∏™ÂáΩÊï∞ÔºåÂπ∂Êää `self`Ôºà‰πüÂ∞±ÊòØ `Server` ÁªèÁêÜÂØπË±°Ôºâ‰Ωú‰∏∫‰∏ä‰∏ãÊñá‰ø°ÊÅØÔºà`userdata`Ôºâ‰º†ÁªôÂÆÉ„ÄÇ‚Äù

#### `acceptCallback` ÂáΩÊï∞ÔºöÂÆ¢‰∫∫ËøõÈó®

ÂΩì‰∏Ä‰∏™Êñ∞ËøûÊé•ÁúüÁöÑÂà∞Êù•Êó∂Ôºå`xev` ‰ºöËá™Âä®Ë∞ÉÁî®Ëøô‰∏™ÂáΩÊï∞„ÄÇ

```zig
fn acceptCallback(...) xev.CallbackAction {
    // ...
    const client_tcp = result catch { ... }; // 1. ÊãøÂà∞‰∏éÊñ∞ÂÆ¢‰∫∫ÁöÑ‚ÄúÁîµËØùÁ∫ø‚Äù

    if (!server.connection_pool.tryAcquire()) { // 2. ÈóÆÈ¢Ü‰ΩçÂëòÊòØÂê¶Êª°Â∫ß
        // ... Êª°‰∫ÜÂ∞±ÊãíÁªù
    }

    // 3. ÂàÜÈÖç‰∏Ä‰∏™‚ÄúÊúçÂä°Âëò‚Äù(ClientConnection)
    const client_conn = ...;
    client_conn.* = ClientConnection.init(client_tcp, server, server.allocator);

    // 4. ËÆæÁΩÆ‰∏ã‰∏Ä‰∏™ÈìÉÈìõÔºÅ
    client_tcp.read(loop, &client_conn.read_completion, .{ .slice = &client_conn.buffer }, ClientConnection, client_conn, readCallback);

    return .rearm; // 5. ËøîÂõû .rearm
}
```

Á¨¨4Ê≠•ÊòØÁ¨¨‰∫å‰∏™ÂÖ≥ÈîÆÁöÑ `xev` Ë∞ÉÁî®Ôºö
*   `client_tcp.read(...)`: ÁªèÁêÜÂØπÊñ∞Êù•ÁöÑÊúçÂä°ÂëòËØ¥Ôºö‚ÄúÊ≥®ÊÑèÂê¨Ëøô‰ΩçÂÆ¢‰∫∫ÁÇπÈ§ê„ÄÇÂΩì‰ªñÂºÄÂßãËØ¥ËØùÔºàÂèëÈÄÅÊï∞ÊçÆÔºâÊó∂ÔºåÊëá‰∏Ä‰∏ãÈìÉÈìõ„ÄÇ‚Äù
*   `.slice = &client_conn.buffer`: ÊääÂÆ¢‰∫∫ËØ¥ÁöÑËØùÔºàÊï∞ÊçÆÔºâËÆ∞ÂΩïÂà∞Ëøô‰ΩçÊúçÂä°ÂëòÁöÑÁÇπÈ§êÊú¨ (`buffer`) Èáå„ÄÇ
*   `ClientConnection, client_conn, readCallback`: ÂëäËØâ `xev`Ôºö‚ÄúÂΩìÊï∞ÊçÆ‰º†Êù•Êó∂ÔºåËØ∑Ë∞ÉÁî® `readCallback` ÂáΩÊï∞ÔºåÂπ∂Êää `client_conn`ÔºàËøô‰ΩçÊúçÂä°ÂëòÔºâ‰Ωú‰∏∫‰∏ä‰∏ãÊñá‰º†ÁªôÂÆÉ„ÄÇ‚Äù

Á¨¨5Ê≠•ÁöÑ `return .rearm;` ‰πüÂæàÈáçË¶Å„ÄÇÂÆÉÂëäËØâ `xev`Ôºö‚ÄúËøôÊ¨°ÁöÑÂÆ¢‰∫∫ÊàëÂ§ÑÁêÜÂ•Ω‰∫ÜÔºåËØ∑**ÈáçÊñ∞ÈÉ®ÁΩ≤Ôºàre-armÔºâ**Ëøô‰∏™ `accept` ÈìÉÈìõÔºåÊàëËøòË¶ÅÁªßÁª≠Êé•ÂæÖ‰∏ã‰∏Ä‰ΩçÂÆ¢‰∫∫„ÄÇ‚Äù

#### `readCallback` ÂáΩÊï∞ÔºöÂÆ¢‰∫∫ÁÇπÈ§ê

ÂΩìÂÆ¢Êà∑Á´ØÂèëÈÄÅÊï∞ÊçÆÊó∂Ôºå`xev` ‰ºöË∞ÉÁî®Ëøô‰∏™ÂáΩÊï∞„ÄÇ

```zig
fn readCallback(...) xev.CallbackAction {
    // ...
    const bytes_read = result catch { ... }; // 1. Êî∂Âà∞ÂÆ¢‰∫∫ËØ¥ÁöÑËØùÔºàÊï∞ÊçÆÔºâ

    if (bytes_read == 0) { // 2. Â¶ÇÊûúÂÆ¢‰∫∫ÊåÇ‰∫ÜÁîµËØùÔºàËøûÊé•ÂÖ≥Èó≠Ôºâ
        client_conn.close(loop); // Â∞±ÁªìÊùüÊúçÂä°
        return .disarm;
    }

    // 3. ÊääÊï∞ÊçÆËøΩÂä†Âà∞ÂÆåÊï¥ÁöÑÁÇπÈ§êËÆ∞ÂΩï(request_buffer)Èáå
    // ...

    // 4. Ê£ÄÊü•ÂÆ¢‰∫∫ÊòØÂê¶ËØ¥ÂÆå‰∫ÜÂÆåÊï¥ÁöÑ‰∏ÄÂè•ËØùÔºàHTTPËØ∑Ê±ÇÊòØÂê¶ÂÆåÊï¥Ôºâ
    if (should_process) {
        // 5a. Â¶ÇÊûúËØ¥ÂÆå‰∫ÜÔºåÊääËÆ¢Âçï‰∫§ÁªôÂé®ÊàøÂ§ÑÁêÜ
        processHttpRequestFromBuffer(client_conn, loop) catch { ... };
        return .disarm; // ËÆ¢ÂçïÂ∑≤Êé•Êî∂ÔºåËøô‰∏™‚ÄúËØª‚ÄùÁöÑ‰ªªÂä°ÂÆåÊàê‰∫ÜÔºåËß£Èô§ÈÉ®ÁΩ≤
    } else {
        // 5b. Â¶ÇÊûúÊ≤°ËØ¥ÂÆåÔºåËÆæÁΩÆÂêå‰∏Ä‰∏™ÈìÉÈìõÔºåÁªßÁª≠Âê¨
        client_conn.tcp.read(loop, &client_conn.read_completion, ...);
        return .disarm; // ÊóßÁöÑ‚ÄúËØª‚Äù‰ªªÂä°ÂÆåÊàêÔºå‰ΩÜÊàë‰ª¨È©¨‰∏äËÆæ‰∫Ü‰∏™Êñ∞ÁöÑÔºåÊïàÊûúÁ±ª‰ººÈáçÊñ∞ÈÉ®ÁΩ≤
    }
}
```
`return .disarm;` ÁöÑÊÑèÊÄùÊòØÔºö‚ÄúËøôÊ¨°ÁöÑ‚ÄòËØª‚Äô‰∫ã‰ª∂ÊàëÂ§ÑÁêÜÂÆå‰∫ÜÔºåËØ∑**Ëß£Èô§ÈÉ®ÁΩ≤ÔºàdisarmÔºâ**Ëøô‰∏™ÈìÉÈìõ„ÄÇÊàë‰∏çÈúÄË¶Å‰Ω†ÂÜç‰∏∫**ËøôÊ¨°**ËØªÊìç‰ΩúÈÄöÁü•Êàë‰∫Ü„ÄÇ‚Äù ÔºàÂ¶ÇÊûúÈúÄË¶ÅÁªßÁª≠ËØªÔºåÊàë‰ª¨‰ºöÊâãÂä®ËÆæÁΩÆ‰∏Ä‰∏™Êñ∞ÁöÑ `read` ‰ªªÂä°ÔºåÂ∞±ÂÉè `5b` ÈÇ£Ê†∑Ôºâ„ÄÇ

#### `processHttpRequestFromBuffer` ÂáΩÊï∞ÔºöÂé®ÊàøÂ§ÑÁêÜËÆ¢Âçï

Ëøô‰∏™ÂáΩÊï∞‰∏çÊòØÂõûË∞ÉÔºåËÄåÊòØÊàë‰ª¨Ëá™Â∑±ÁöÑÈÄªËæë„ÄÇÂÆÉËß£ÊûêËØ∑Ê±ÇÔºåÈÄöËøá `router`ÔºàËèúÂçïÔºâÊâæÂà∞ÂØπÂ∫îÁöÑÂ§ÑÁêÜÂáΩÊï∞ÔºàÂé®Â∏àÔºâÔºåÁîüÊàê `HttpResponse`ÔºàËèúÂìÅÔºâÔºåÁÑ∂ÂêéË∞ÉÁî® `sendResponse` ‰∏äËèú„ÄÇ

#### `sendResponse` & `writeCallback` ÂáΩÊï∞Ôºö‰∏äËèú‰∏éÁ°ÆËÆ§

`sendResponse` ÂáΩÊï∞ÈáåÊúâÁ¨¨‰∏â‰∏™ÂÖ≥ÈîÆÁöÑ `xev` Ë∞ÉÁî®Ôºö
```zig
fn sendResponse(...) {
    // ...
    client_conn.response_data = response_data; // ÈáçË¶ÅÔºöÂÖàÊääËèúÁ´ØÂú®ÊâòÁõò‰∏äÔºåÈò≤Ê≠¢Ë¢´ÂõûÊî∂
    client_conn.tcp.write(loop, &client_conn.write_completion, .{ .slice = response_data }, ClientConnection, client_conn, writeCallback);
}
```
*   `client_conn.tcp.write(...)`: ‚ÄúÂòøÔºå`xev`ÔºåËØ∑ÊääËøô‰ªΩ `response_data`ÔºàËèúÔºâÂèëÁªôÂÆ¢‰∫∫„ÄÇÂèëÈÄÅ**ÂÆåÊàê**ÂêéÔºåËØ∑Êëá‰∏Ä‰∏ãÈìÉÈìõÔºåË∞ÉÁî® `writeCallback` ÂáΩÊï∞„ÄÇ‚Äù

ÂΩìÊï∞ÊçÆÂèëÈÄÅÂÆåÊØïÂêéÔºå`writeCallback` Ë¢´Ë∞ÉÁî®Ôºö
```zig
fn writeCallback(...) xev.CallbackAction {
    // ...
    log.info("‚úÖ Sent {} bytes response", .{bytes_written}); // Á°ÆËÆ§ËèúÂ∑≤ÈÄÅÂà∞

    // ‰∏äÂÆåËèúÔºåÊúçÂä°ÁªìÊùü
    client_conn.close(loop);
    return .disarm; // ‚ÄúÂÜô‚Äù‰ªªÂä°ÂÆåÊàêÔºåËß£Èô§ÈÉ®ÁΩ≤
}
```
#### `closeCallback` ÂáΩÊï∞ÔºöÂÆ¢‰∫∫Á¶ªÂ∏≠

`writeCallback` Ë∞ÉÁî® `client_conn.close(loop)`ÔºåËÄå `close` ÂáΩÊï∞ÂÜÖÈÉ®‰ºöËÆæÁΩÆÊúÄÂêé‰∏Ä‰∏™ÈìÉÈìõÔºö
```zig
fn close(...) {
    // ...
    self.tcp.close(loop, &self.close_completion, ClientConnection, self, closeCallback);
}
```
*   `self.tcp.close(...)`: ‚ÄúÂòø `xev`ÔºåËØ∑ÂÖ≥Èó≠Ëøô‰∏™ËøûÊé•„ÄÇÂΩì**ÂÆåÂÖ®ÂÖ≥Èó≠**ÂêéÔºåËØ∑ÊëáÈìÉÔºåË∞ÉÁî® `closeCallback`„ÄÇ‚Äù

ÂΩìËøûÊé•ÂΩªÂ∫ïÊñ≠ÂºÄÂêéÔºå`closeCallback` Ë¢´Ë∞ÉÁî®ÔºåÂÆÉ‰ºöÊâßË°åÊúÄÁªàÁöÑÊ∏ÖÁêÜÂ∑•‰ΩúÔºåÊØîÂ¶ÇÈáäÊîæÊúçÂä°Âëò `client_conn` Âç†Áî®ÁöÑÊâÄÊúâÂÜÖÂ≠ò (`client_conn.deinit()`)„ÄÇ

---

### ÊÄªÁªì

Ëøô‰∏™ `lib.zig` Êñá‰ª∂ÈÄöËøáÂá†‰∏™Ê†∏ÂøÉÁöÑ `struct` Êù•ÁÆ°ÁêÜÁä∂ÊÄÅÔºåÂπ∂Âà©Áî® `xev` Â∫ìÊèê‰æõÁöÑ**‰∫ã‰ª∂Âæ™ÁéØÂíåÂõûË∞ÉÊú∫Âà∂**ÔºåÊûÑÂª∫‰∫Ü‰∏Ä‰∏™È´òÊïàÁöÑÂºÇÊ≠•ÊúçÂä°Âô®„ÄÇ

Êï¥‰∏™ÊµÅÁ®ãÂ∞±ÂÉè‰∏Ä‰∏™È´òÂ∫¶ÂçèÂêåÁöÑÈ§êÂéÖÔºö
1.  `listen`ÔºöÈ§êÂéÖÂºÄÈó®ÔºåÁªèÁêÜÂºÄÂßãÂÖ≥Ê≥®Â§ßÈó®ÁöÑ `accept` ÈìÉÈìõ„ÄÇ
2.  `acceptCallback`ÔºöÂÆ¢‰∫∫ËøõÈó®ÔºåÂàÜÈÖç‰∏Ä‰∏™ÊúçÂä°ÂëòÔºåÂπ∂ËÆ©ÊúçÂä°ÂëòÂÖ≥Ê≥®ÂÆ¢‰∫∫ÁöÑ `read` ÈìÉÈìõ„ÄÇ
3.  `readCallback`ÔºöÂÆ¢‰∫∫ÁÇπÈ§êÔºåÊúçÂä°ÂëòËÆ∞ÂΩïÔºåÁÇπÂÆåÂêéÊääËÆ¢ÂçïÈÄÅÂéªÂé®Êàø„ÄÇ
4.  `processHttpRequest...`ÔºöÂé®ÊàøÂÅöËèú„ÄÇ
5.  `sendResponse`ÔºöÊúçÂä°Âëò‰∏äËèúÔºåÂπ∂ÂÖ≥Ê≥® `write` ÈìÉÈìõÔºåÁ°ÆËÆ§ÂÆ¢‰∫∫Êî∂Âà∞„ÄÇ
6.  `writeCallback`ÔºöÂÆ¢‰∫∫Êî∂Âà∞ËèúÔºåÊúçÂä°ÂëòÂºÄÂßãÊ∏ÖÁêÜÊ°åÈù¢Ôºà`close`Ôºâ„ÄÇ
7.  `closeCallback`ÔºöÂÆ¢‰∫∫Á¶ªÂ∏≠ÔºåÊúçÂä°ÂëòÂíåÊ°åÂ≠êË¢´ÂÆåÂÖ®ÈáäÊîæÔºåÂèØ‰ª•ÊúçÂä°‰∏ã‰∏Ä‰ΩçÂÆ¢‰∫∫„ÄÇ

Êï¥‰∏™ËøáÁ®ãÔºåÁªèÁêÜÔºà‰∏ªÁ∫øÁ®ãÔºâ‰ªé‰∏çÁ≠âÂæÖ‰ªª‰Ωï‰∏Ä‰∏™ÂÆ¢‰∫∫Ôºå‰ªñÂè™ÂìçÂ∫îÂêÑÁßç‚ÄúÈìÉÈìõ‚ÄùÂ£∞ÔºåÂõ†Ê≠§ÂèØ‰ª•ÂêåÊó∂‰∏∫ÊàêÂçÉ‰∏ä‰∏áÁöÑÂÆ¢‰∫∫Êèê‰æõÈ´òÊïàÊúçÂä°„ÄÇËøôÂ∞±ÊòØÂºÇÊ≠•ÁºñÁ®ãÁöÑÂ®ÅÂäõÔºÅ


cmpxchgWeak ‰∏∫‰ªÄ‰πà‰∏çÁõ¥Êé•Áî® fetchAdd Ôºü

ËøôÊòØ‰∏Ä‰∏™ÊûÅÂÖ∂Ê∑±ÂàªÂíåÂá∫Ëâ≤ÁöÑÈóÆÈ¢òÔºÅÂÆÉÁõ¥Êé•Ëß¶Âèä‰∫ÜÂπ∂ÂèëÁºñÁ®ã‰∏≠ÁÆóÊ≥ïËÆæËÆ°ÁöÑÊ†∏ÂøÉ„ÄÇ‰Ω†ÈóÆÂà∞‰∫ÜÁÇπÂ≠ê‰∏ä„ÄÇ

‰∏∫‰ªÄ‰πàÂú® tryAcquire ‰∏≠‰∏çÁõ¥Êé•Áî® fetchAdd(1, .acq_rel) ËÄåÊòØÁî®‰∏Ä‰∏™ÁúãËµ∑Êù•Êõ¥Â§çÊùÇÁöÑ cmpxchgWeak Âæ™ÁéØÂë¢Ôºü

ÁÆÄÁü≠ÁöÑÂõûÁ≠îÊòØÔºöÊàë‰ª¨ÈúÄË¶ÅÂú®Â¢ûÂä†ËÆ°Êï∞ÂÄº‰πãÂâçÔºåÂÖàÂÅö‰∏Ä‰∏™Ê£ÄÊü•Ôºàif (current >= self.max_connections)Ôºâ„ÄÇfetchAdd Êó†Ê≥ïÂ∞ÜËøô‰∏™Ê£ÄÊü•ÂíåÂ¢ûÂä†Êìç‰ΩúÁªëÂÆöÊàê‰∏Ä‰∏™ÂéüÂ≠êÊ≠•È™§„ÄÇ

ËØ¶ÁªÜËß£ÊûêÔºöÂéüÂ≠êÊìç‰ΩúÁöÑ‚Äú‰∏çÂèØÂàÜÂâ≤ÊÄß‚Äù

Êàë‰ª¨ÂÜçÂõûÈ°æ‰∏Ä‰∏ã‚ÄúÂéüÂ≠ê‚ÄùÁöÑÂÆö‰πâÔºö‰∏çÂèØÂàÜÂâ≤„ÄÇ

fetchAdd(1, ...) ÊòØ‰∏Ä‰∏™Âçï‰∏ÄÁöÑ„ÄÅÂéüÂ≠êÁöÑÊìç‰Ωú„ÄÇÂÆÉÁöÑÂÖ®ÈÉ®ËÅåË¥£Â∞±ÊòØÔºö‚ÄúÊääÂÄºÂä†1‚Äù„ÄÇÂÆÉÂÅöÂæóÈùûÂ∏∏Âá∫Ëâ≤Ôºå‰ΩÜ‰πüÂ∞±‰ªÖÊ≠§ËÄåÂ∑≤„ÄÇ

Êàë‰ª¨ÁöÑ tryAcquire ÈÄªËæëÈúÄË¶ÅÂÅö‰∏§‰ª∂‰∫ãÔºö

Ê£ÄÊü•ÔºöÂΩìÂâçËøûÊé•Êï∞ÊòØÂê¶Â∞è‰∫éÊúÄÂ§ßÈôêÂà∂Ôºü

Â¢ûÂä†ÔºöÂ¶ÇÊûúÂ∞è‰∫éÔºåÂ∞±ÊääËøûÊé•Êï∞Âä†1„ÄÇ

Â¶ÇÊûúÊàë‰ª¨Â∞ùËØïÁî® fetchAdd Êù•ÂÆûÁé∞Ôºå‰ª£Á†ÅÂèØËÉΩ‰ºöÂÉèËøôÊ†∑ÔºàËøôÊòØÈîôËØØÁ§∫ËåÉÔºÅÔºâÔºö

code
Zig
download
content_copy
expand_less

// ÈîôËØØÁ§∫ËåÉÔºöÊó†Ê≥ïÂ∑•‰ΩúÁöÑ tryAcquire
fn tryAcquire_WRONG(self: *ConnectionPool) bool {
    // Á¨¨‰∏ÄÊ≠•ÔºöÂÖàËØªÂèñÂΩìÂâçÂÄº
    const current = self.active_connections.load(.acquire);

    // Á¨¨‰∫åÊ≠•ÔºöÊ£ÄÊü•
    if (current >= self.max_connections) {
        return false;
    }

    // Á¨¨‰∏âÊ≠•ÔºöÂ¢ûÂä†
    // ÈóÆÈ¢òÊù•‰∫ÜÔºÅ
    _ = self.active_connections.fetchAdd(1, .acq_rel);

    return true;
}

ËøôÊÆµ‰ª£Á†ÅÂ≠òÂú®‰∏Ä‰∏™Â∑®Â§ßÁöÑÁ´ûÊÄÅÊù°‰ª∂ÔºàRace ConditionÔºâÔºåÊàë‰ª¨Áî®‰∏Ä‰∏™Âú∫ÊôØÊù•ËØ¥ÊòéÔºö

ÂÅáËÆæ max_connections ÊòØ 100„ÄÇ

Á∫øÁ®ãA ÊâßË°åÂà∞Á¨¨‰∏ÄÊ≠•ÔºåËØªÂèñ current ‰∏∫ 99„ÄÇ

Á∫øÁ®ãB ‰πüÊâßË°åÂà∞Á¨¨‰∏ÄÊ≠•Ôºå‰πüËØªÂèñ current ‰∏∫ 99„ÄÇ

Á∫øÁ®ãA ÊâßË°åÁ¨¨‰∫åÊ≠•Ôºå99 < 100ÔºåÊ£ÄÊü•ÈÄöËøá„ÄÇ

Á∫øÁ®ãB ‰πüÊâßË°åÁ¨¨‰∫åÊ≠•Ôºå99 < 100ÔºåÊ£ÄÊü•‰πüÈÄöËøá„ÄÇ

Á∫øÁ®ãA ÊâßË°åÁ¨¨‰∏âÊ≠•ÔºåË∞ÉÁî® fetchAddÔºåactive_connections ÂèòÊàê‰∫Ü 100„ÄÇ

Á∫øÁ®ãB ‰πüÊâßË°åÁ¨¨‰∏âÊ≠•ÔºåË∞ÉÁî® fetchAddÔºåactive_connections ÂèòÊàê‰∫Ü 101ÔºÅ

ÁÅæÈöæÂèëÁîü‰∫ÜÔºÅ Êàë‰ª¨Á™ÅÁ†¥‰∫Ü max_connections ÁöÑÈôêÂà∂„ÄÇÊúçÂä°Âô®ÁöÑÈÄªËæëË¢´Á†¥Âùè‰∫Ü„ÄÇ

ÈóÆÈ¢òÂ∞±Âá∫Âú®**‚ÄúÊ£ÄÊü•‚ÄùÂíå‚ÄúÂ¢ûÂä†‚ÄùËøô‰∏§‰∏™Ê≠•È™§‰∏çÊòØÂéüÂ≠êÁöÑ**„ÄÇÂú®ÂÆÉ‰ª¨‰πãÈó¥Â≠òÂú®‰∏Ä‰∏™Êó∂Èó¥Á™óÂè£ÔºåÂÖ∂‰ªñÁ∫øÁ®ãÂèØ‰ª•Ë∂ÅËôöËÄåÂÖ•„ÄÇ

cmpxchg Âæ™ÁéØÁöÑÂ®ÅÂäõÔºöÂ∞Ü‚ÄúÊ£ÄÊü•‚Äù‰∏é‚Äú‰øÆÊîπ‚ÄùÊçÜÁªë

Áé∞Âú®ÔºåÊàë‰ª¨ÂÜçÂõûÂ§¥Áúã cmpxchgWeak Âæ™ÁéØÁöÑÂÆûÁé∞Ôºö

code
Zig
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
fn tryAcquire(self: *ConnectionPool) bool {
    while (true) {
        // 1. ËØªÂèñÂΩìÂâçÂÄº (Êàë‰ª¨ÁöÑ‚ÄúÁåúÊµã‚Äù)
        const current = self.active_connections.load(.acquire);

        // 2. Âü∫‰∫éÁåúÊµãËøõË°åÊ£ÄÊü•
        if (current >= self.max_connections) {
            return false;
        }

        // 3. Â∞ùËØïÂéüÂ≠êÊÄßÂú∞‚ÄúÁ°ÆËÆ§ÁåúÊµãÂπ∂‰øÆÊîπ‚Äù
        if (self.active_connections.cmpxchgWeak(current, current + 1, ...) == null) {
            // ÊàêÂäüÔºÅ
            return true;
        }
        // Â¶ÇÊûúÂ§±Ë¥•ÔºåÂæ™ÁéØ‰ºöÁ´ãÂç≥ÈáçËØï
    }
}

Ëøô‰∏™Âæ™ÁéØÂ∑ßÂ¶ôÂú∞Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇcmpxchgWeak Ëøô‰∏™Êìç‰ΩúÊú¨Ë∫´Â∞±ÂåÖÂê´‰∫Ü**‚ÄúÊ£ÄÊü•ÔºàÊØîËæÉÔºâ‚Äù** Âíå ‚Äú‰øÆÊîπÔºà‰∫§Êç¢Ôºâ‚Äù„ÄÇ

ËÆ©Êàë‰ª¨Áî®ÂêåÊ†∑ÁöÑÂú∫ÊôØÂÜçËµ∞‰∏ÄÈÅçÊµÅÁ®ãÔºö

max_connections ÊòØ 100„ÄÇactive_connections ÂΩìÂâçÊòØ 99„ÄÇ

Á∫øÁ®ãA ËøõÂÖ•Âæ™ÁéØÔºö

load ÂæóÂà∞ current ÊòØ 99„ÄÇ

Ê£ÄÊü• 99 < 100 ÈÄöËøá„ÄÇ

Â∞ùËØï cmpxchgWeak(99, 100, ...)„ÄÇ

Â∞±Âú®Á∫øÁ®ãAÂ∞ùËØï cmpxchg ÁöÑÁû¨Èó¥ÔºåCPUÂàáÊç¢Âà∞‰∫Ü Á∫øÁ®ãB„ÄÇ

Á∫øÁ®ãB ËøõÂÖ•Âæ™ÁéØÔºö

load ÂæóÂà∞ current ÊòØ 99„ÄÇ

Ê£ÄÊü• 99 < 100 ÈÄöËøá„ÄÇ

Â∞ùËØï cmpxchgWeak(99, 100, ...)„ÄÇÂÅáËÆæ Á∫øÁ®ãB ÂÖàÊàêÂäü‰∫Ü„ÄÇ

active_connections ÁöÑÂÄºÁé∞Âú®ÂéüÂ≠êÊÄßÂú∞ÂèòÊàê‰∫Ü 100„ÄÇ

Á∫øÁ®ãBÁöÑ tryAcquire ËøîÂõû true„ÄÇ

CPUÂàáÊç¢Âõû Á∫øÁ®ãAÔºåÁªßÁª≠ÊâßË°åÂÆÉÁöÑ cmpxchgWeak(99, 100, ...)„ÄÇ

CPUÁé∞Âú®ËøõË°åÊØîËæÉÔºö‚ÄúÂòøÔºåactive_connections ÁöÑÂÄºËøòÊòØ 99 ÂêóÔºü‚Äù

Á≠îÊ°àÊòØÔºö‚Äú‰∏çÊòØÔºÅÂÆÉÁé∞Âú®ÊòØ 100 ‰∫ÜÔºÅ‚Äù

‰∫éÊòØÔºåcmpxchgWeak Â§±Ë¥•Ôºå‰∏çÊâßË°å‰ªª‰Ωï‰øÆÊîπ„ÄÇ

Á∫øÁ®ãA ÁöÑ if Âà§Êñ≠Â§±Ë¥•ÔºåÂÆÉ‰∏ç‰ºöËøîÂõû true„ÄÇÂÆÉ‰ºöÂõûÂà∞ while Âæ™ÁéØÁöÑÈ°∂ÈÉ®ÔºåÂºÄÂßãÊñ∞‰∏ÄËΩÆÁöÑÂ∞ùËØï„ÄÇ

Á∫øÁ®ãA ÁöÑÁ¨¨‰∫åËΩÆÂæ™ÁéØÔºö

load ÂæóÂà∞ current ÊòØ 100„ÄÇ

Ê£ÄÊü• 100 >= 100ÔºåÊù°‰ª∂ÊàêÁ´ã„ÄÇ

if ËØ≠Âè•ÊâßË°åÔºåÂáΩÊï∞ËøîÂõû false„ÄÇ

ÊúÄÁªàÁªìÊûúÔºö ‰∏Ä‰∏™Á∫øÁ®ãÊàêÂäüÂú∞Â∞ÜËÆ°Êï∞Âô®Âä†Âà∞‰∫Ü 100ÔºåÂè¶‰∏Ä‰∏™Á∫øÁ®ãÂÆâÂÖ®Âú∞Â§±Ë¥•‰∫Ü„ÄÇËøûÊé•Êï∞‰ªéÊú™Ë∂ÖËøá 100„ÄÇÈÄªËæëÂÆåÁæéÊó†Áº∫„ÄÇ

ÊÄªÁªì

cmpxchgÔºàCompare-and-SwapÔºåÊØîËæÉÂπ∂‰∫§Êç¢ÔºâÊòØÂÆûÁé∞ÊâÄË∞ìÁöÑ**‚ÄúÊó†ÈîÅÔºàLock-FreeÔºâ‚Äù**ÁÆóÊ≥ïÁöÑÂü∫Áü≥„ÄÇËøô‰∏™Âæ™ÁéØÊ®°ÂºèË¢´Áß∞‰∏∫ CAS Loop„ÄÇ

ÂΩì‰Ω†ÁöÑÈÄªËæëÊòØÁÆÄÂçïÁöÑ**‚ÄúÊó†Êù°‰ª∂‰øÆÊîπ‚Äù**ÔºàÊØîÂ¶Ç release Êó∂Êó†Êù°‰ª∂Âáè1ÔºâÔºåÈÇ£‰πà fetchAdd / fetchSub ÊòØÊúÄ‰Ω≥ÈÄâÊã©ÔºåÂõ†‰∏∫ÂÆÉÊõ¥ÁÆÄÂçï„ÄÅÊÑèÂõæÊõ¥ÊòéÁ°Æ„ÄÇ

ÂΩì‰Ω†ÈúÄË¶Å**‚ÄúÊúâÊù°‰ª∂ÁöÑ‰øÆÊîπ‚Äù**ÔºàÊØîÂ¶Ç tryAcquire Êó∂ÔºåÂè™ÊúâÂú®Êú™Êª°ÁöÑÊÉÖÂÜµ‰∏ãÊâçÂä†1ÔºâÔºåfetchAdd Â∞±Êó†ËÉΩ‰∏∫Âäõ‰∫ÜÔºåÂõ†‰∏∫‰Ω†Êó†Ê≥ïÊää‰Ω†ÁöÑ‚ÄúÊù°‰ª∂‚ÄùÂ°ûËøõËøô‰∏™ÂéüÂ≠êÊìç‰ΩúÈáå„ÄÇËøôÊó∂ÔºåCAS Loop Â∞±ÊòØÊ†áÂáÜÁöÑ„ÄÅÊúÄÈ´òÊïàÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇÂÆÉÂÖÅËÆ∏‰Ω†Âú®ÊôÆÈÄö‰ª£Á†Å‰∏≠ËøõË°å‰ªªÊÑèÂ§çÊùÇÁöÑÈÄªËæëÂà§Êñ≠ÔºåÁÑ∂ÂêéÈÄöËøá‰∏ÄÊ¨°ÂéüÂ≠êÁöÑ cmpxchg Êìç‰ΩúÊù•Êèê‰∫§‰Ω†ÁöÑ‰øÆÊîπÔºåÂêåÊó∂Á°Æ‰øùÂú®Ê≠§ÊúüÈó¥ÂÖ±‰∫´Áä∂ÊÄÅÊ≤°ÊúâË¢´ÂÖ∂‰ªñ‰∫∫ÊîπÂèò„ÄÇ



.acq_rel Âíå .release Êúâ‰Ωï‰∏çÂêåÔºü

Â§™Ê£í‰∫ÜÔºÅËøô‰∏™ÈóÆÈ¢òÊ†áÂøóÁùÄ‰Ω†Â∑≤Áªè‰ªé‚ÄúÂ¶Ç‰Ωï‰ΩøÁî®‚ÄùÁöÑÂ±ÇÈù¢ÔºåÊ∑±ÂÖ•Âà∞‰∫Ü‚Äú‰∏∫‰ªÄ‰πàËøôÊ†∑ËÆæËÆ°‚ÄùÁöÑÊ†∏ÂøÉ„ÄÇ`.acq_rel` Âíå `.release` ÁöÑÂå∫Âà´ÊòØÂπ∂ÂèëÁºñÁ®ã‰∏≠ÊúÄÁ≤æÂ¶ô‰πüÊúÄÈáçË¶ÅÁöÑÊ¶ÇÂøµ‰πã‰∏Ä„ÄÇ

‰∏∫‰∫ÜÁêÜËß£ÂÆÉÔºåÊàë‰ª¨ÂøÖÈ°ªÂÖàÁêÜËß£‰∏Ä‰∏™‚ÄúÂèØÊÄï‚ÄùÁöÑ‰∫ãÂÆûÔºö**‰∏∫‰∫ÜËøΩÊ±ÇÊûÅËá¥ÁöÑÈÄüÂ∫¶ÔºåÁºñËØëÂô®ÂíåCPU‰ºöÊìÖËá™Êâì‰π±‰Ω†ÂÜôÁöÑ‰ª£Á†ÅÊåá‰ª§È°∫Â∫èÔºÅ**

### ËÉåÊôØÔºöÊ∑∑‰π±ÁöÑÂäûÂÖ¨ÂÆ§

ÊÉ≥Ë±°‰∏Ä‰∏ãÔºå‰Ω†Âíå‰Ω†ÁöÑÂêå‰∫ãÂú®‰∏Ä‰∏™Â§ßÂäûÂÖ¨ÂÆ§ÈáåÂçèÂêåÂ∑•‰ΩúÔºå‰Ω†‰ª¨ÂÖ±‰∫´‰∏ÄÂùóÂ∑®Â§ßÁöÑ**ÁôΩÊùøÔºà‰∏ªÂÜÖÂ≠òÔºâ**„ÄÇ‰ΩÜ‰∏∫‰∫ÜÊïàÁéáÔºåÊØè‰∏™‰∫∫Èù¢ÂâçÈÉΩÊúâ‰∏ÄÂº†**‰æøÁ≠æÁ∫∏ÔºàCPUÁºìÂ≠òÔºâ**„ÄÇ

*   ÂΩì‰Ω†ÂÜô‰∏úË•øÊó∂Ôºå‰Ω†ÈÄöÂ∏∏‰ºöÂÖàÂÜôÂú®Ëá™Â∑±ÁöÑ‰æøÁ≠æÁ∫∏‰∏ä„ÄÇ
*   ÂΩì‰Ω†ËØª‰∏úË•øÊó∂Ôºå‰Ω†‰πü‰ºòÂÖàÁúãËá™Â∑±ÁöÑ‰æøÁ≠æÁ∫∏„ÄÇ
*   Âè™ÊúâÂú®ÁâπÂÆöÁöÑÊó∂ÂÄôÔºå‰Ω†Êâç‰ºöÊää‰æøÁ≠æÁ∫∏‰∏äÁöÑÂÜÖÂÆπÂêåÊ≠•Âà∞‰∏≠Â§ÆÁöÑÂ§ßÁôΩÊùø‰∏äÔºåÊàñËÄÖ‰ªéÂ§ßÁôΩÊùø‰∏äÊõ¥Êñ∞Ëá™Â∑±ÁöÑ‰æøÁ≠æÁ∫∏„ÄÇ

Êõ¥Á≥üÁ≥ïÁöÑÊòØÔºåÊØè‰∏™‰∫∫ÈÉΩÊúâ‰∏Ä‰∏™‚ÄúËÅ™ÊòéÁöÑ‚ÄùÁßÅ‰∫∫Âä©ÁêÜÔºàÁºñËØëÂô®/CPU‰π±Â∫èÊâßË°åÂºïÊìéÔºâ„ÄÇ‰∏∫‰∫ÜËÆ©‰Ω†Êõ¥Âø´Âú∞ÂÆåÊàê‰ªªÂä°ÂàóË°®ÔºåÂä©ÁêÜÂèØËÉΩ‰ºöÊâì‰π±‰Ω†ÁöÑ‰ªªÂä°È°∫Â∫è„ÄÇÊØîÂ¶Ç‰Ω†ÂÜôÁùÄÔºö
1.  ÂáÜÂ§áÂ•ΩÊä•ÂëäÊï∞ÊçÆ„ÄÇ
2.  Âú®ÁôΩÊùø‰∏äÂÜô‰∏ã‚ÄúÊä•ÂëäÂ∑≤ÂÆåÊàê‚Äù„ÄÇ

‰Ω†ÁöÑÂä©ÁêÜÂèØËÉΩ‰ºöËÆ§‰∏∫Á¨¨‰∫åÊ≠•‰∏ç‰æùËµñÁ¨¨‰∏ÄÊ≠•Ôºå‰∏∫‰∫Ü‚ÄúÊïàÁéá‚ÄùÔºåÂÖàÊääÁ¨¨‰∫åÊ≠•ÂÅö‰∫ÜÔºÅËøôÂ∞±ÂØºËá¥‰Ω†ÁöÑÂêå‰∫ãÁúãÂà∞‰∫Ü‚ÄúÊä•ÂëäÂ∑≤ÂÆåÊàê‚ÄùÔºå‰ΩÜÂéªÊãøÊï∞ÊçÆÊó∂Âç¥ÂèëÁé∞ÊòØÁ©∫ÁöÑÊàñÊóßÁöÑ„ÄÇ

**ÂÜÖÂ≠òÈ°∫Â∫èÔºàMemory OrderingÔºâÂ∞±ÊòØ‰Ω†Áªô‰Ω†ÁöÑ‚ÄúÂä©ÁêÜ‚Äù‰∏ãËææÁöÑÂº∫Âà∂Êåá‰ª§ÔºåÂëäËØâ‰ªñÔºö‚ÄúËøôÈáåÁöÑÈ°∫Â∫èÁªùÂØπ‰∏çËÉΩ‰π±ÔºÅ‚Äù**

---

### `.release`ÔºöÂèëÂ∏ÉËÄÖ/Áªô‰∫àËÄÖ ÁöÑËßÑÂàô

`Ordering.release` Áî®‰∫é**ÂÜôÂÖ•ÊàñÂ≠òÂÇ®ÔºàStoreÔºâ**Êìç‰Ωú„ÄÇÂÆÉÂª∫Á´ã‰∫Ü‰∏Ä‰∏™‚ÄúÂèëÂ∏É‚ÄùÂ±èÈöú„ÄÇ

**ËßÑÂàôÔºö** Âú®ÊàëÊâßË°åËøô‰∏™ `release` ÂÜôÂÖ•Êìç‰Ωú**‰πãÂâç**ÁöÑÊâÄÊúâÂÜÖÂ≠òÂÜôÂÖ•ÔºåÂøÖÈ°ªÂÖà‰∫éËøô‰∏™Êìç‰ΩúÂÆåÊàê„ÄÇÁªù‰∏çËÉΩÊääÂÆÉ‰ª¨ÈáçÊéíÂà∞Ëøô‰∏™ `release` Êìç‰Ωú**‰πãÂêé**„ÄÇ

**ÁôΩÊùøÊØîÂñªÔºö**
`release` Â∞±ÂÉè‰Ω†ÂØπÂä©ÁêÜËØ¥Ôºö‚Äú**ÂÖàÊääÊâÄÊúâÊä•ÂëäÊï∞ÊçÆÈÉΩÂÜôÂà∞ÁôΩÊùø‰∏äÔºåÁÑ∂ÂêéÔºå‰πüÂè™ËÉΩÂú®Ëøô‰πãÂêéÔºåÊâçËÉΩÂú®ÁôΩÊùø‰∏äÂÜô‰∏ã‚ÄòÊä•ÂëäÂ∑≤ÂÆåÊàê‚ÄôÁöÑÊ†áÂøó„ÄÇ**‚Äù

ÂÆÉÁ°Æ‰øù‰∫ÜÂõ†ÊûúÂÖ≥Á≥ªÔºö**Âõ†ÔºàÊï∞ÊçÆÂáÜÂ§áÂ•ΩÔºâ** ÂøÖÈ°ªÂèëÁîüÂú® **ÊûúÔºàÊ†áÂøóË¢´ËÆæÁΩÆÔºâ** ‰πãÂâç„ÄÇ

**`ConnectionPool.release()` ‰∏≠ÁöÑÂ∫îÁî®ÔºàÁÆÄÂåñÁâàÔºâÔºö**
ÂÅáËÆæ `release()` ÂÜÖÈÉ®ÁöÑ‰ª£Á†ÅÊòØËøôÊ†∑ÁöÑÔºö
```zig
// ‰º™‰ª£Á†Å
self.some_other_data = 123; // ‰∏Ä‰∫õÂÖ∂‰ªñÁöÑÂÜôÂÖ•Êìç‰Ωú
_ = self.active_connections.fetchSub(1, .release); // ‰ΩøÁî® .release
```
`.release` ‰øùËØÅ‰∫Ü `self.some_other_data = 123` Ëøô‰∏™Êìç‰ΩúÁöÑÁªìÊûúÔºåÂØπ‰∫éÂÖ∂‰ªñÁ∫øÁ®ãÊù•ËØ¥Ôºå‰∏ÄÂÆöÂú® `active_connections` ÁöÑÂÄºÂáèÂ∞ë‰πãÂâçÂ∞±ÂèØËßÅ‰∫Ü„ÄÇ

---

### `.acquire`ÔºöÊé•Êî∂ËÄÖ/Ëé∑ÂèñËÄÖ ÁöÑËßÑÂàô

`Ordering.acquire` Áî®‰∫é**ËØªÂèñÊàñÂä†ËΩΩÔºàLoadÔºâ**Êìç‰Ωú„ÄÇÂÆÉÂª∫Á´ã‰∫Ü‰∏Ä‰∏™‚ÄúËé∑Âèñ‚ÄùÂ±èÈöú„ÄÇ

**ËßÑÂàôÔºö** Âú®ÊàëÊâßË°åËøô‰∏™ `acquire` ËØªÂèñÊìç‰Ωú**‰πãÂêé**ÁöÑÊâÄÊúâÂÜÖÂ≠òËØªÂèñÔºåÂøÖÈ°ªÂú®ÊàëËøô‰∏™Êìç‰ΩúÂÆåÊàê‰πãÂêéÊâçËÉΩÊâßË°å„ÄÇÁªù‰∏çËÉΩÊääÂÆÉ‰ª¨ÈáçÊéíÂà∞Ëøô‰∏™ `acquire` Êìç‰Ωú**‰πãÂâç**„ÄÇ

**ÁôΩÊùøÊØîÂñªÔºö**
`acquire` Â∞±ÂÉè‰Ω†ÂØπÂä©ÁêÜËØ¥Ôºö‚Äú**‰Ω†ÂøÖÈ°ªÂÖàÁ°ÆËÆ§‰Ω†ÁúãÂà∞‰∫ÜÁôΩÊùø‰∏äÁöÑ‚ÄòÊä•ÂëäÂ∑≤ÂÆåÊàê‚ÄôÊ†áÂøóÔºåÁÑ∂ÂêéÔºå‰πüÂè™ËÉΩÂú®Ëøô‰πãÂêéÔºåÊâçËÉΩÂéªËØªÂèñÊä•ÂëäÊï∞ÊçÆ„ÄÇ**‚Äù

ÂÆÉÁ°Æ‰øù‰∫ÜÊ≠£Á°ÆÁöÑËßÇÂØüÈ°∫Â∫èÔºö**‰Ω†ÂøÖÈ°ªÂÖàÁúãÂà∞Ê†áÂøóÔºàÊûúÔºâÔºåÊâçËÉΩÂÆâÂÖ®Âú∞ÂéªËØªÂèñÊï∞ÊçÆÔºàÂõ†Ôºâ**„ÄÇ

`release` Âíå `acquire` ÂøÖÈ°ªÊàêÂØπÂá∫Áé∞ÊâçËÉΩÊûÑÊàêÂÆåÊï¥ÁöÑÂêåÊ≠•„ÄÇ‰∏Ä‰∏™Á∫øÁ®ãÁî® `release` ÂèëÂ∏ÉÔºåÂè¶‰∏Ä‰∏™Á∫øÁ®ãÁî® `acquire` Êé•Êî∂ÔºåÂÆÉ‰ª¨ÂÖ±ÂêåÁ°Æ‰øù‰∫ÜÊï∞ÊçÆÂú®Á∫øÁ®ãÈó¥ÁöÑÂÆâÂÖ®‰º†ÈÄí„ÄÇ

---

### `.acq_rel`ÔºöÈõÜÂèëÂ∏É‰∏éÊé•Êî∂‰∫é‰∏ÄË∫´ÔºàÂÖ®ËÉΩÈÄâÊâãÔºâ

`Ordering.acq_rel` (Acquire-Release) Áî®‰∫é**‚ÄúËØªÂèñ-‰øÆÊîπ-ÂÜôÂÖ•‚ÄùÔºàRead-Modify-Write, RMWÔºâ**Á±ªÂûãÁöÑÊìç‰Ωú„ÄÇ

`fetchSub`, `fetchAdd`, `cmpxchg` Ëøô‰∫õÊìç‰ΩúÊú¨Ë¥®‰∏äÈÉΩÂåÖÂê´‰∫Ü‰∏â‰∏™Ê≠•È™§Ôºö
1.  **ËØªÂèñ**ÂÜÖÂ≠ò‰∏≠ÁöÑÊóßÂÄº„ÄÇ
2.  Âú®CPUÂÜÖÈÉ®ËøõË°å**‰øÆÊîπ**ÔºàÂä†/Âáè/ÊØîËæÉÔºâ„ÄÇ
3.  **ÂÜôÂÖ•**‰øÆÊîπÂêéÁöÑÊñ∞ÂÄºÂà∞ÂÜÖÂ≠ò„ÄÇ

ÊâÄ‰ª•ÔºåËøôÁßçÊìç‰ΩúÊó¢ÊòØ‚ÄúÊé•Êî∂ËÄÖ‚ÄùÔºàÂõ†‰∏∫ÂÆÉËØªÂèñ‰∫ÜÊóßÁä∂ÊÄÅÔºâÔºåÂèàÊòØ‚ÄúÂèëÂ∏ÉËÄÖ‚ÄùÔºàÂõ†‰∏∫ÂÆÉÂèëÂ∏É‰∫ÜÊñ∞Áä∂ÊÄÅÔºâ„ÄÇÂõ†Ê≠§ÔºåÂÆÉÈúÄË¶ÅÂêåÊó∂ÈÅµÂÆà‰∏§ÁßçËßÑÂàô„ÄÇ

**ËßÑÂàôÔºö**
1.  **Acquire ÈÉ®ÂàÜÔºö** Âú®ÊàëÊâßË°åËøô‰∏™RMWÊìç‰Ωú**‰πãÂêé**ÁöÑÊâÄÊúâÂÜÖÂ≠òËØªÂÜôÔºåÈÉΩ‰∏çËÉΩË¢´ÈáçÊéíÂà∞ÂÆÉ**‰πãÂâç**„ÄÇ
2.  **Release ÈÉ®ÂàÜÔºö** Âú®ÊàëÊâßË°åËøô‰∏™RMWÊìç‰Ωú**‰πãÂâç**ÁöÑÊâÄÊúâÂÜÖÂ≠òËØªÂÜôÔºåÈÉΩ‰∏çËÉΩË¢´ÈáçÊéíÂà∞ÂÆÉ**‰πãÂêé**„ÄÇ

**ÁôΩÊùøÊØîÂñªÔºö**
`acq_rel` Â∞±ÂÉè‰∏Ä‰∏™**‰∏≠ÂøÉÂçèË∞ÉÂëòÂú®Êõ¥Êñ∞ÁôΩÊùø‰∏äÁöÑ‰∏Ä‰∏™ÂÖ±‰∫´ËÆ°Êï∞Âô®**„ÄÇ
1.  **AcquireËßÑÂàôÔºö** ‚ÄúÂú®ÊàëËØªÂèñËÆ°Êï∞Âô®ÁöÑÊóßÂÄº‰πãÂâçÔºåÊàëÂøÖÈ°ªÂÖàÁúãÂà∞ÁôΩÊùø‰∏äÊâÄÊúâÂÖ∂‰ªñ‰∫∫Â∑≤ÁªèÂÆåÊàêÁöÑÂ∑•‰Ωú„ÄÇ‚Äù
2.  **ReleaseËßÑÂàôÔºö** ‚ÄúÂú®ÊàëÂÜô‰∏ãËÆ°Êï∞Âô®ÁöÑÊñ∞ÂÄº‰πãÂêéÔºåÊàëÊâçÁÆóÂÆåÊàê‰∫ÜÊàëÁöÑÊõ¥Êñ∞„ÄÇÊàë‰πãÂâçÂÅöÁöÑÊâÄÊúâÂáÜÂ§áÂ∑•‰ΩúÔºåÁé∞Âú®ÈÉΩÂØπÂÖ∂‰ªñ‰∫∫ÂèØËßÅ‰∫Ü„ÄÇ‚Äù

ÂÆÉÂàõÂª∫‰∫Ü‰∏Ä‰∏™ÂèåÂêëÁöÑÂ±èÈöúÔºåÁ°Æ‰øùËøô‰∏™ÂéüÂ≠êÊìç‰ΩúÊàê‰∏∫‰∏Ä‰∏™ÊòéÁ°ÆÁöÑÂêåÊ≠•ÁÇπÔºå‰πãÂâçÁöÑÊâÄÊúâÊìç‰ΩúÂØπ‰πãÂêéÁöÑÊìç‰ΩúÂèØËßÅ„ÄÇ

### ÂõûÂà∞Êàë‰ª¨ÁöÑ‰ª£Á†Å

*   **`release()` ‰∏≠ÁöÑ `fetchSub(1, .acq_rel)`:**
    *   ‰∏∫‰ªÄ‰πàÊòØ `.acq_rel` ËÄå‰∏ç‰ªÖ‰ªÖÊòØ `.release`ÔºüÂõ†‰∏∫ `fetchSub` ÊòØ‰∏Ä‰∏™RMWÊìç‰Ωú„ÄÇÂç≥‰ΩøÊàë‰ª¨Áî® `_ =` ÂøΩÁï•‰∫ÜÂÆÉËøîÂõûÁöÑÊóßÂÄºÔºåCPU‰ªçÁÑ∂ÊâßË°å‰∫Ü‚ÄúËØªÂèñ-‰øÆÊîπ-ÂÜôÂÖ•‚ÄùÁöÑÂÆåÊï¥ËøáÁ®ã„ÄÇ‰ΩøÁî® `.acq_rel` ÊòØÊúÄÂÆâÂÖ®ÁöÑÈÄâÊã©ÔºåÂÆÉÁ°Æ‰øùËøô‰∏™ÂáèÊ≥ïÊìç‰ΩúËÉΩÊ≠£Á°ÆÂú∞‰∏éÂÖ∂‰ªñÁ∫øÁ®ãÁöÑÂéüÂ≠êÊìç‰ΩúÂêåÊ≠•„ÄÇÂú®ËÆ∏Â§öCPUÊû∂ÊûÑÔºàÂ¶Çx86Ôºâ‰∏äÔºåRMWÊìç‰ΩúÈªòËÆ§Â∞±ÊòØÂÆåÂÖ®ÂêåÊ≠•ÁöÑÔºåÊâÄ‰ª•‰ΩøÁî® `.acq_rel` Ê≤°ÊúâÈ¢ùÂ§ñÁöÑÊÄßËÉΩÂºÄÈîÄÔºå‰ΩÜ‰ª£Á†ÅÁöÑÊÑèÂõæÊõ¥Ê≠£Á°Æ„ÄÅÊõ¥ÂÆâÂÖ®„ÄÇ

*   **`tryAcquire()` ‰∏≠ÁöÑ `cmpxchgWeak(..., .acq_rel, .acquire)`:**
    *   Á¨¨‰∏Ä‰∏™ `.acq_rel` Áî®‰∫é**ÊàêÂäü**ÁöÑË∑ØÂæÑ„ÄÇÂ¶ÇÊûúÊØîËæÉÊàêÂäüÂπ∂‰∫§Êç¢‰∫ÜÂÄºÔºåËøôÊòØ‰∏Ä‰∏™ÂÆåÊï¥ÁöÑRMWÊìç‰ΩúÔºåÈúÄË¶Å `acq_rel` ËØ≠‰πâ„ÄÇ
    *   Á¨¨‰∫å‰∏™ `.acquire` Áî®‰∫é**Â§±Ë¥•**ÁöÑË∑ØÂæÑ„ÄÇÂ¶ÇÊûúÊØîËæÉÂ§±Ë¥•Ôºå`cmpxchg` ‰ªçÁÑ∂ÊâßË°å‰∫Ü‰∏ÄÊ¨°**ËØªÂèñ**Êìç‰ΩúÔºàÂÆÉËØªÂà∞‰∫Ü‰∏Ä‰∏™‰∏éÈ¢ÑÊúü‰∏çÁ¨¶ÁöÑÂÄºÔºâ„ÄÇËøôÊ¨°ËØªÂèñÈúÄË¶ÅÊúâ `acquire` ËØ≠‰πâÔºå‰ª•Á°Æ‰øùÂú®Âæ™ÁéØÁöÑ‰∏ã‰∏ÄÊ¨°Ëø≠‰ª£‰∏≠ÔºåÊàë‰ª¨ËÉΩÁúãÂà∞ÂØºËá¥Â§±Ë¥•ÁöÑÈÇ£‰∏™Á∫øÁ®ãÊâÄÂÅöÁöÑÊâÄÊúâÂÜôÂÖ•„ÄÇ

### ÊÄªÁªìË°®Ê†º

| ÂÜÖÂ≠òÈ°∫Â∫è     | Êìç‰ΩúÁ±ªÂûã          | ‰ΩúÁî®                                       | ÊØîÂñª                                             |
|--------------|-------------------|--------------------------------------------|--------------------------------------------------|
| `.release`   | **ÂÜôÂÖ• (Store)**  | ‰øùËØÅ**‰πãÂâç**ÁöÑÂÜôÂÖ•‰∏ç‰ºöË¢´ÈáçÊéíÂà∞**‰πãÂêé**„ÄÇ   | ÂÖàÂÜôÂ•ΩÊï∞ÊçÆÔºåÂÜçÊåÇÂá∫‚ÄúÂÆåÊàê‚ÄùÁöÑÁâåÂ≠ê„ÄÇ                 |
| `.acquire`   | **ËØªÂèñ (Load)**   | ‰øùËØÅ**‰πãÂêé**ÁöÑËØªÂèñ‰∏ç‰ºöË¢´ÈáçÊéíÂà∞**‰πãÂâç**„ÄÇ   | ÂÖàÁúãÂà∞‚ÄúÂÆåÊàê‚ÄùÁöÑÁâåÂ≠êÔºåÂÜçËøõÂéªËØªÊï∞ÊçÆ„ÄÇ               |
| `.acq_rel`   | **ËØª-Êîπ-ÂÜô (RMW)**| ÂêåÊó∂ÂÖ∑Â§á `acquire` Âíå `release` ÁöÑÂèåÂêëÂ±èÈöú„ÄÇ | Êõ¥Êñ∞ÂÖ±‰∫´ËÆ°Êï∞Âô®ÔºöÊó¢Ë¶ÅÁúãÂà∞Âà´‰∫∫ÁöÑÊõ¥Êñ∞Ôºå‰πüË¶ÅÂèëÂ∏ÉËá™Â∑±ÁöÑÊõ¥Êñ∞„ÄÇ |

ÁêÜËß£Ëøô‰∫õÂÜÖÂ≠òÈ°∫Â∫èÊòØÁºñÂÜôÊ≠£Á°Æ„ÄÅÈ´òÊïàÁöÑÊó†ÈîÅÂπ∂Âèë‰ª£Á†ÅÁöÑÂÖ≥ÈîÆ„ÄÇÂÆÉ‰ª¨ÊòØÁ®ãÂ∫èÂëò‰∏éÁºñËØëÂô®ÂíåCPU‰πãÈó¥ÂÖ≥‰∫é‚ÄúÊåá‰ª§È°∫Â∫è‚ÄùÁöÑ‚ÄúÂêõÂ≠êÂçèÂÆö‚Äù„ÄÇ



listen, readCallback, processHttpRequestFromBuffer, writeCallback Ëøô‰∫õÂáΩÊï∞‰ºöË¢´Â§öÁ∫øÁ®ãÊâßË°åÂêóÔºüxev ‰∏≠Âì™ÈÉ®ÂàÜ‰ª£Á†Å‰ºöË¢´Â§öÁ∫øÁ®ãÊâßË°åÔºåÈúÄË¶ÅÂÅöÁ∫øÁ®ãÂêåÊ≠•Ôºü


ËøôÊòØ‰∏Ä‰∏™Áõ¥ÂáªÁÅµÈ≠ÇÁöÑÂ•ΩÈóÆÈ¢òÔºÅÂÆÉËß¶Âèä‰∫Ü `libxev` ËøôÁ±ªÂºÇÊ≠•Ê°ÜÊû∂ÁöÑÊ†∏ÂøÉÂ∑•‰ΩúÊ®°ÂºèÔºå‰ª•ÂèäÊàë‰ª¨‰Ωú‰∏∫Â∫îÁî®ÂºÄÂèëËÄÖÈúÄË¶ÅÊ≥®ÊÑèÁöÑËæπÁïå„ÄÇ

Á≠îÊ°àÂèØËÉΩÊúâÁÇπÂèçÁõ¥ËßâÔºö**Âú®ÈªòËÆ§ÈÖçÁΩÆ‰∏ãÔºå`listen` ÂáΩÊï∞ÈáåÁöÑ‰∫ã‰ª∂Âæ™ÁéØÔºå‰ª•ÂèäÊâÄÊúâÁöÑÂõûË∞ÉÂáΩÊï∞Ôºà`acceptCallback`, `readCallback`, `writeCallback`, `closeCallback`ÔºâÈÉΩËøêË°åÂú®Âêå‰∏Ä‰∏™Á∫øÁ®ã‰∏≠ÔºÅ**

ËøôÂê¨Ëµ∑Êù•ÂæàÂ•áÊÄ™ÔºåÂØπÂêßÔºü‰∏Ä‰∏™Á∫øÁ®ãÊÄé‰πàËÉΩÂêåÊó∂Â§ÑÁêÜÊàêÂçÉ‰∏ä‰∏áÁöÑËøûÊé•Âë¢ÔºüËÆ©Êàë‰ª¨Êù•Êè≠ÂºÄËøô‰∏™‚ÄúÂçïÁ∫øÁ®ãÂπ∂Âèë‚ÄùÈ≠îÊ≥ïÁöÑÁ•ûÁßòÈù¢Á∫±„ÄÇ

---

### Á¨¨‰∏ÄÈÉ®ÂàÜÔºö`xev` ÁöÑÊ†∏ÂøÉÂ∑•‰ΩúÊ®°Âºè‚Äî‚ÄîÂçïÁ∫øÁ®ã‰∫ã‰ª∂Âæ™ÁéØ

ÊÉ≥Ë±°‰∏Ä‰∏™Âé®Ëâ∫Á≤æÊπõÁöÑ**‚ÄúÁ´†È±º‚ÄùÂé®Â∏à**„ÄÇ‰ªñÂè™Êúâ‰∏Ä‰∏™Â§ßËÑëÔºà**‰∏Ä‰∏™Á∫øÁ®ã**ÔºâÔºå‰ΩÜÊúâÂæàÂ§öÂè™ÊâãÔºà**I/OÂ§öË∑ØÂ§çÁî®**ÔºåÂ¶Ç `epoll`, `kqueue`, `IOCP`Ôºâ„ÄÇ

1.  **`listen()` ÂáΩÊï∞ÁöÑ `loop.run()`:**
    ËøôÁõ∏ÂΩì‰∫éÂé®Â∏àËØ¥Ôºö‚ÄúÂ•Ω‰∫ÜÔºåÊàëÂºÄÂßãÂ∑•‰Ωú‰∫ÜÔºÅ‚Äù ‰ªñÁ´ôÂú®Âé®Êàø‰∏≠Â§ÆÔºåÈù¢ÂâçÊòØ‰∏Ä‰∏™Â∑®Â§ßÁöÑ**ËÆ¢ÂçïÁõëÊéßÈù¢Êùø**ÔºàÁî±Êìç‰ΩúÁ≥ªÁªüÂÜÖÊ†∏Êèê‰æõÁöÑI/OÂ§öË∑ØÂ§çÁî®Êú∫Âà∂Ôºâ„ÄÇ

2.  **Ê≥®ÂÜå‰∫ã‰ª∂:**
    *   `tcp_server.accept(...)` ÊòØÂëäËØâÁõëÊéßÈù¢ÊùøÔºö‚ÄúÂΩìÈó®Âè£ÊúâÊñ∞ÂÆ¢‰∫∫Êó∂ÔºåËØ∑Âú®Èù¢Êùø‰∏ä‰∫Æ‰∏ÄÁõèÁ∫¢ÁÅØ„ÄÇ‚Äù
    *   `client_tcp.read(...)` ÊòØÂëäËØâÁõëÊéßÈù¢ÊùøÔºö‚ÄúÂΩìAÊ°åÁöÑÂÆ¢‰∫∫ÂºÄÂßãÁÇπËèúÊó∂ÔºåËØ∑Âú®Èù¢Êùø‰∏ä‰∫Æ‰∏ÄÁõèÈªÑÁÅØ„ÄÇ‚Äù
    *   `client_tcp.write(...)` ÊòØÂëäËØâÁõëÊéßÈù¢ÊùøÔºö‚ÄúÂΩìBÊ°åÁöÑËèúÊàêÂäüÈÄÅËææÊó∂ÔºåËØ∑Âú®Èù¢Êùø‰∏ä‰∫Æ‰∏ÄÁõèÁªøÁÅØ„ÄÇ‚Äù

3.  **‰∫ã‰ª∂Âæ™ÁéØÔºàThe LoopÔºâ:**
    Âé®Â∏àÁöÑÂ§ßËÑëÔºàÁ∫øÁ®ãÔºâÁé∞Âú®ËøõÂÖ•‰∏Ä‰∏™ÈùûÂ∏∏ÁÆÄÂçïÁöÑÂæ™ÁéØÔºö
    *   **Ê≠•È™§1ÔºöÁù°Ëßâ/Á≠âÂæÖ (Blocking Call)**
        Âé®Â∏àÂØπÁõëÊéßÈù¢ÊùøËØ¥Ôºö‚ÄúÊúâ‰ªª‰ΩïÁÅØ‰∫Æ‰∫ÜÂêóÔºüÂ¶ÇÊûúÊ≤°ÊúâÔºåÊàëÂ∞±Âú®ËøôÈáåÁ≠âÁùÄÔºàÈòªÂ°ûÔºâ„ÄÇ‰∏ÄÊúâÁÅØ‰∫ÆÔºåÁ´ãÂàªÂè´ÈÜíÊàëÔºåÂπ∂ÂëäËØâÊàë**Âì™‰∫õ**ÁÅØ‰∫Æ‰∫Ü„ÄÇ‚Äù
        ËøôÊòØÊï¥‰∏™Ê®°ÂûãÊúÄÈ´òÊïàÁöÑÂú∞Êñπ„ÄÇÂΩìÊ≤°Êúâ‰∫ãÊÉÖÂèëÁîüÊó∂Ôºå**Á∫øÁ®ãÂÆåÂÖ®‰∏çÊ∂àËÄóCPU**ÔºåÂÆÉÂú®Áù°Ëßâ„ÄÇ

    *   **Ê≠•È™§2ÔºöÂ§ÑÁêÜ‰∫ã‰ª∂ (Dispatching Callbacks)**
        ÁõëÊéßÈù¢ÊùøÂè´ÈÜí‰∫ÜÂé®Â∏àÔºåÂπ∂ÈÄíÁªô‰ªñ‰∏ÄÂº†Ê∏ÖÂçïÔºö‚ÄúÁ∫¢ÁÅØ‰∫Æ‰∫ÜÔºÅÈªÑÁÅØ‰πü‰∫Æ‰∫ÜÔºÅ‚Äù
        Âé®Â∏àÁöÑÂ§ßËÑëÔºà**‰ªçÁÑ∂ÊòØÈÇ£Âêå‰∏Ä‰∏™Á∫øÁ®ã**Ôºâ‰ºö‰æùÊ¨°Â§ÑÁêÜËøô‰∫õ‰∫ã‰ª∂Ôºö
        *   ‚ÄúÂì¶ÔºåÁ∫¢ÁÅØ‰∫Æ‰∫ÜÔºåËØ¥ÊòéÊúâÊñ∞ÂÆ¢‰∫∫„ÄÇÊàëÊù•ÊâßË°å `acceptCallback`„ÄÇ‚Äù ‰ªñÁî®‰∏ÄÂè™ÊâãËøÖÈÄüÊé•ÂæÖÂÆ¢‰∫∫ÔºåÂπ∂ÂëäËØâÁõëÊéßÈù¢ÊùøÁõëÂê¨Ëøô‰ΩçÊñ∞ÂÆ¢‰∫∫ÁöÑ‚ÄúÁÇπËèú‚Äù‰∫ã‰ª∂„ÄÇ
        *   ‚ÄúÂì¶ÔºåÈªÑÁÅØ‰∫Æ‰∫ÜÔºåËØ¥ÊòéAÊ°åÁöÑÂÆ¢‰∫∫Âú®ÁÇπËèú„ÄÇÊàëÊù•ÊâßË°å `readCallback`„ÄÇ‚Äù ‰ªñÁî®Âè¶‰∏ÄÂè™ÊâãÂø´ÈÄüËÆ∞‰∏ãËèúÂçïÔºåÁÑ∂ÂêéÂÜ≥ÂÆöÊòØÁªßÁª≠Âê¨ËøòÊòØÊääËÆ¢ÂçïÈÄÅÂéªÂé®Êàø„ÄÇ
        *   ...Â§ÑÁêÜÂÆåÊ∏ÖÂçï‰∏äÁöÑÊâÄÊúâ‰∫ã‰ª∂„ÄÇ

    *   **Ê≠•È™§3ÔºöÂõûÂà∞Ê≠•È™§1**
        Â§ÑÁêÜÂÆåÊâÄÊúâ‰∫ÆÁÅØÁöÑ‰∫ã‰ª∂ÂêéÔºåÂé®Â∏àÂÜçÊ¨°ÂõûÂà∞ÁõëÊéßÈù¢ÊùøÂâçÔºåÁªßÁª≠Á≠âÂæÖ‰∏ã‰∏ÄÊâπ‰∫ÆÁÅØ„ÄÇ

**ÁªìËÆ∫1Ôºö** Âú®Ëøô‰∏™Ê®°Âûã‰∏≠Ôºå`acceptCallback`, `readCallback`, `writeCallback` Á≠âÊâÄÊúâÂõûË∞ÉÂáΩÊï∞ÔºåÈÉΩÊòØÁî±**Âêå‰∏Ä‰∏™Á∫øÁ®ã**ÊåâÈ°∫Â∫è**‰∏≤Ë°åÊâßË°å**ÁöÑ„ÄÇÂú®‰∏Ä‰∏™ÂõûË∞ÉÂáΩÊï∞ÊâßË°åÂÆåÊàê‰πãÂâçÔºå‰∏ã‰∏Ä‰∏™ÂõûË∞ÉÁªùÂØπ‰∏ç‰ºöÂºÄÂßã„ÄÇ**Âõ†Ê≠§ÔºåÂú®Ëøô‰∫õÂõûË∞ÉÂáΩÊï∞ÂÜÖÈÉ®Ôºå‰Ω†‰∏çÈúÄË¶ÅÊãÖÂøÉÂÆÉ‰ª¨‰πãÈó¥ÁöÑÊï∞ÊçÆÁ´û‰∫âÈóÆÈ¢ò„ÄÇ** ‰æãÂ¶ÇÔºå‰Ω†ÂèØ‰ª•Âú® `readCallback` ÈáåÂÆâÂÖ®Âú∞‰øÆÊîπ `ClientConnection` ÁöÑÊüê‰∏™Â≠óÊÆµÔºåËÄå‰∏çÁî®ÊãÖÂøÉ `writeCallback` Âú®Âêå‰∏ÄÊó∂Âàª‰πüÂú®‰øÆÊîπÂÆÉ„ÄÇ

---

### Á¨¨‰∫åÈÉ®ÂàÜÔºö`xev` ÁöÑÁ∫øÁ®ãÊ±†‚Äî‚ÄîÊääËÄóÊó∂‰ªªÂä°ÊâîÁªôÂà´‰∫∫

‚ÄúÁ´†È±º‚ÄùÂé®Â∏àÈùûÂ∏∏ÊìÖÈïøÂ§ÑÁêÜÈÇ£‰∫õ‚ÄúÁ≠âÂæÖ‚ÄùÁ±ªÂíå‚ÄúÈÄüÊàòÈÄüÂÜ≥‚ÄùÁ±ªÁöÑ‰ªªÂä°ÔºàÊØîÂ¶ÇÊé•ÂæÖÂÆ¢‰∫∫„ÄÅËÆ∞ËèúÂçïÔºâ„ÄÇ‰ΩÜÂ¶ÇÊûú‰∏Ä‰∏™ËÆ¢ÂçïÈùûÂ∏∏Â§çÊùÇÔºåÈúÄË¶ÅÈïøÊó∂Èó¥ÁöÑÂàáËèú„ÄÅÁÇñÁÖÆÔºà**CPUÂØÜÈõÜÂûã‰ªªÂä°**ÔºâÔºåÈÇ£‰ºöÊÄé‰πàÊ†∑Ôºü

Â¶ÇÊûúÂé®Â∏à‰∫≤Ëá™ÂéªÂÅöËøô‰∏™ËÄóÊó∂ÁöÑ‰ªªÂä°Ôºå‰ªñÂ∞±‰ºöË¢´Âõ∞Âú®ÁÅ∂Âè∞ÂâçÔºåÊó†Ê≥ïÂÜçÂéªÂÖ≥Ê≥®ÁõëÊéßÈù¢Êùø‰∏äÁöÑÊñ∞‰∫ÆÁÅØ„ÄÇÊï¥‰∏™È§êÂéÖÔºàÊúçÂä°Âô®ÔºâÈÉΩ‰ºöË¢´**ÈòªÂ°û**ÔºåÊó†Ê≥ïÂìçÂ∫î‰ªª‰ΩïÊñ∞ËØ∑Ê±Ç„ÄÇ

ËøôÂ∞±ÊòØ `xev` Á∫øÁ®ãÊ±†ÂèëÊå•‰ΩúÁî®ÁöÑÂú∞Êñπ„ÄÇ

Âú® `listen` ÂáΩÊï∞‰∏≠ÔºåÊúâËøôÊ†∑‰∏ÄÊÆµ‰ª£Á†ÅÔºö
```zig
var libxev_thread_pool: ?xev.ThreadPool = null;
if (self.config.enable_thread_pool) {
    libxev_thread_pool = xev.ThreadPool.init(...);
}

var loop = try xev.Loop.init(.{
    .thread_pool = if (libxev_thread_pool) |*pool| pool else null,
});
```

*   **`xev.ThreadPool.init(...)`**: ËøôÁõ∏ÂΩì‰∫éÊàë‰ª¨È¢ùÂ§ñÈõá‰Ω£‰∫Ü‰∏ÄÈòü**‚ÄúÂ∏ÆÂé®‚ÄùÔºàÂ∑•‰ΩúÁ∫øÁ®ãÔºâ**„ÄÇ‰ªñ‰ª¨‰∏çË¥üË¥£Êé•ÂæÖÂÆ¢‰∫∫ÂíåÁõëÊéßÈù¢ÊùøÔºåÂè™Ë¥üË¥£ÂüãÂ§¥Âπ≤Ê¥ª„ÄÇ
*   **`loop.init(.{ .thread_pool = ... })`**: ËøôÁõ∏ÂΩì‰∫éÁ´†È±ºÂé®Â∏àÊãøÂà∞‰∫ÜÂ∏ÆÂé®Âõ¢ÈòüÁöÑËÅîÁ≥ªÊñπÂºè„ÄÇ

Áé∞Âú®Ôºå`xev` Êèê‰æõ‰∫ÜÁâπÊÆäÁöÑÂäüËÉΩÔºåÊØîÂ¶Ç `loop.queueWork()`ÔºàÊàñËÄÖÂú®ÂÖ∂‰ªñÁ±ª‰ººÁöÑÂ∫ì‰∏≠ÔºâÔºåËÆ©‰∏ªÂé®ÂèØ‰ª•ÊääËÄóÊó∂‰ªªÂä°Â§ñÂåÖÂá∫Âéª„ÄÇ

**Â∏¶Á∫øÁ®ãÊ±†ÁöÑÂ∑•‰ΩúÊµÅÁ®ãÔºö**
1.  **‰∫ã‰ª∂Âæ™ÁéØÁ∫øÁ®ãÔºà‰∏ªÂé®Ôºâ** ÁöÑ `readCallback` Êé•Êî∂Âà∞‰∏Ä‰∏™ÂÆåÊï¥ÁöÑËØ∑Ê±Ç„ÄÇ
2.  ÂÆÉÂèëÁé∞Ëøô‰∏™ËØ∑Ê±ÇÈúÄË¶ÅËøõË°åÂ§çÊùÇÁöÑËÆ°ÁÆóÔºàÊØîÂ¶ÇÂõæÂÉèÂ§ÑÁêÜ„ÄÅÂ§çÊùÇÁöÑÊï∞ÊçÆÂ∫ìÊü•ËØ¢Á≠âÔºâ„ÄÇ
3.  ÂÆÉ‰∏ç‰ºöËá™Â∑±ÂéªÂÅöÔºåËÄåÊòØÊääËøô‰∏™‰ªªÂä°ÊâìÂåÖÔºåÈÄöËøá `loop.queueWork()` ‰∫§Áªô**Á∫øÁ®ãÊ±†ÔºàÂ∏ÆÂé®Âõ¢ÈòüÔºâ**„ÄÇ
4.  ÂÆÉ‰ºöÂëäËØâÁ∫øÁ®ãÊ±†Ôºö‚ÄúÂÆåÊàê‰ªªÂä°ÂêéÔºåËØ∑ÈÄöÁü•ÊàëÔºàÈÄöËøá‰∏Ä‰∏™ÂõûË∞ÉÔºâ„ÄÇ‚Äù
5.  ÁÑ∂ÂêéÔºå**‰∏ªÂé®Á´ãÂàªËøîÂõû**ÔºåÁªßÁª≠ÂÖ≥Ê≥®‰ªñÁöÑÁõëÊéßÈù¢ÊùøÔºåÂ§ÑÁêÜÂÖ∂‰ªñËøûÊé•„ÄÇ‰ªñÊ≤°ÊúâË¢´ÈòªÂ°û„ÄÇ
6.  Á∫øÁ®ãÊ±†ÈáåÁöÑÊüê‰∏™**Á©∫Èó≤ÁöÑÂ∏ÆÂé®Á∫øÁ®ã**‰ºöÊãøËµ∑Ëøô‰∏™‰ªªÂä°ÔºåÂºÄÂßãÊâßË°å„ÄÇ**ËøôÈÉ®ÂàÜ‰ª£Á†ÅÊòØÂú®‰∏Ä‰∏™ÂÆåÂÖ®‰∏çÂêåÁöÑÁ∫øÁ®ã‰∏≠ËøêË°åÁöÑÔºÅ**
7.  ÂΩìÂ∏ÆÂé®ÂÆåÊàê‰∫Ü‰ªªÂä°Ôºå‰ªñ‰ºöÈÄöÁü•‰∫ã‰ª∂Âæ™ÁéØ„ÄÇ
8.  Âú®‰∫ã‰ª∂Âæ™ÁéØÁöÑ‰∏ã‰∏ÄÊ¨°Ëø≠‰ª£‰∏≠Ôºå‰∏ªÂé®‰ºöÁúãÂà∞‚Äú‰ªªÂä°ÂÆåÊàê‚ÄùÁöÑÈÄöÁü•ÔºåÁÑ∂ÂêéÊâßË°åÂÆåÊàêÂêéÁöÑÂõûË∞ÉÔºàÊØîÂ¶ÇÊääËÆ°ÁÆóÁªìÊûúÈÄöËøá `write` ÂèëÈÄÅÁªôÂÆ¢Êà∑Á´ØÔºâ„ÄÇ

---

### ÊÄªÁªì‰∏éÂõûÁ≠î‰Ω†ÁöÑÈóÆÈ¢ò

1.  **`listen`, `readCallback`, `processHttpRequestFromBuffer`, `writeCallback` ‰ºöË¢´Â§öÁ∫øÁ®ãÊâßË°åÂêóÔºü**
    *   Âú®ÂΩìÂâçÁöÑ‰ª£Á†ÅÂÆûÁé∞‰∏≠Ôºå**ÂÆÉ‰ª¨ÂÖ®ÈÉ®Áî±Âêå‰∏Ä‰∏™‰∏ª‰∫ã‰ª∂Âæ™ÁéØÁ∫øÁ®ãÊâßË°å**„ÄÇ
    *   `listen` ÂáΩÊï∞Êú¨Ë∫´Âè™Âú®ÂêØÂä®Êó∂ÊâßË°å‰∏ÄÊ¨°ÔºåÂÆÉÁöÑÊ†∏ÂøÉ `loop.run()` ‰ºö‚ÄúÈú∏Âç†‚ÄùÂΩìÂâçÁ∫øÁ®ã„ÄÇ
    *   ÊâÄÊúâÁöÑ `*Callback` ÂáΩÊï∞ÈÉΩÊòØË¢´Ëøô‰∏™ `loop` Ë∞ÉÂ∫¶ÁöÑÔºåÊâÄ‰ª•ÂÆÉ‰ª¨ÊòØ**ÂçïÁ∫øÁ®ã„ÄÅ‰∏≤Ë°å**ÊâßË°åÁöÑ„ÄÇ
    *   `processHttpRequestFromBuffer` ÊòØË¢´ `readCallback` Áõ¥Êé•Ë∞ÉÁî®ÁöÑÔºåÊâÄ‰ª•ÂÆÉ‰πüÂíå `readCallback` Âú®Âêå‰∏Ä‰∏™Á∫øÁ®ã„ÄÇ

2.  **`xev` ‰∏≠Âì™ÈÉ®ÂàÜ‰ª£Á†Å‰ºöË¢´Â§öÁ∫øÁ®ãÊâßË°åÔºü**
    *   Â¶ÇÊûú‰Ω†**ÂêØÁî®‰∫ÜÁ∫øÁ®ãÊ±†**ÔºåÂπ∂ÈÄöËøá `xev` Êèê‰æõÁöÑÊé•Âè£ÔºàÂ¶Ç `loop.queueWork()`ÔºåËøô‰∏™Â∫ìÁõÆÂâçÊ≤°Áõ¥Êé•Áî®Ôºå‰ΩÜÊ¶ÇÂøµÊòØËøôÊ†∑ÔºâÊèê‰∫§‰∫ÜÂ∑•‰ΩúÔºåÈÇ£‰πà**Ë¢´Êèê‰∫§ÁöÑÈÇ£‰∏™Â∑•‰ΩúÂáΩÊï∞**‰ºöÂú®Á∫øÁ®ãÊ±†‰∏≠ÁöÑ**Êüê‰∏™Â∑•‰ΩúÁ∫øÁ®ã**ÈáåÊâßË°å„ÄÇ
    *   ‰∫ã‰ª∂Âæ™ÁéØÊú¨Ë∫´ÂíåÂÆÉÁöÑÁõ¥Êé•ÂõûË∞ÉÔºà`accept`, `read`, `write`Ôºâ**Ê∞∏Ëøú**Âú®‰∏ªÁ∫øÁ®ãÊâßË°å„ÄÇ

3.  **ÈúÄË¶ÅÂÅöÁ∫øÁ®ãÂêåÊ≠•ÂêóÔºü**
    *   **Âú®ÂõûË∞ÉÂáΩÊï∞‰πãÈó¥**Ôºö**‰∏çÈúÄË¶Å**„ÄÇÂõ†‰∏∫ÂÆÉ‰ª¨Âú®Âêå‰∏Ä‰∏™Á∫øÁ®ãÈáå‰∏≤Ë°åÊâßË°åÔºåÂ§©ÁÑ∂Â∞±ÊòØÁ∫øÁ®ãÂÆâÂÖ®ÁöÑ„ÄÇ
    *   **Âú®‰∏ªÁ∫øÁ®ãÔºàÂõûË∞ÉÂáΩÊï∞ÔºâÂíåÂ∑•‰ΩúÁ∫øÁ®ãÔºàÁ∫øÁ®ãÊ±†Ôºâ‰πãÈó¥**Ôºö**ÁªùÂØπÈúÄË¶ÅÔºÅ** ËøôÊòØÊúÄÈúÄË¶ÅÂ∞èÂøÉÁöÑÂú∞Êñπ„ÄÇ
        *   Â¶ÇÊûú‰Ω†‰ªé‰∏ªÁ∫øÁ®ãÊää‰∏Ä‰∏™Êï∞ÊçÆÔºàÊØîÂ¶Ç‰∏Ä‰∏™ `Context` ÂØπË±°Ôºâ‰º†ÈÄíÁªôÂ∑•‰ΩúÁ∫øÁ®ãÔºå‰Ω†ÂøÖÈ°ªÁ°Æ‰øùËøô‰∏™Êï∞ÊçÆÂú®Â∑•‰ΩúÁ∫øÁ®ã‰ΩøÁî®ÊúüÈó¥ÊòØÂÆâÂÖ®ÁöÑÔºàÊØîÂ¶ÇÈÄöËøáÂ§çÂà∂ÔºåÊàñËÄÖ‰ΩøÁî®ÈîÅ„ÄÅÂéüÂ≠êÊìç‰ΩúÁ≠âÔºâ„ÄÇ
        *   ÂΩìÂ∑•‰ΩúÁ∫øÁ®ãÂÆåÊàê‰ªªÂä°ÔºåÊääÁªìÊûú‰∫§ËøòÁªô‰∏ªÁ∫øÁ®ãÊó∂ÔºåËøô‰∏™‰∫§Êé•ËøáÁ®ã‰πüÂøÖÈ°ªÊòØÁ∫øÁ®ãÂÆâÂÖ®ÁöÑ„ÄÇ`xev` Êèê‰æõÁöÑÊú∫Âà∂ÔºàÊØîÂ¶ÇÂÆåÊàêÂõûË∞ÉÔºâÈÄöÂ∏∏Â∑≤ÁªèÂ∏Æ‰Ω†Â§ÑÁêÜÂ•Ω‰∫ÜËøô‰∏™‰∫§Êé•ÁöÑÂêåÊ≠•ÈóÆÈ¢ò„ÄÇ

**ÂØπÂΩìÂâç‰ª£Á†ÅÁöÑÂàÜÊûêÔºö**
Ëøô‰∏™ `libxev-http` È°πÁõÆÁõÆÂâçÁöÑ‰ª£Á†ÅÂÆûÁé∞ÈùûÂ∏∏ÁªèÂÖ∏ÂíåÈ´òÊïàÔºåÂÆÉÊääÊâÄÊúâ I/O Êìç‰ΩúÂíåËØ∑Ê±Ç/ÂìçÂ∫îÁöÑÁªÑË£ÖÈÉΩÊîæÂú®‰∫Ü**ÂçïÁ∫øÁ®ã‰∫ã‰ª∂Âæ™ÁéØ**‰∏≠ÔºåËøôÂØπ‰∫éÁªùÂ§ßÂ§öÊï∞WebËØ∑Ê±ÇÔºàÈÄöÂ∏∏ÊòØ I/O ÂØÜÈõÜÂûãÔºåËÄå‰∏çÊòØ CPU ÂØÜÈõÜÂûãÔºâÊù•ËØ¥ÊòØÊÄßËÉΩÊúÄÈ´òÁöÑÊ®°Âºè„ÄÇÂÆÉ**Ê≤°Êúâ**Â∞ÜËØ∑Ê±ÇÂ§ÑÁêÜÈÄªËæëÔºà`processHttpRequestFromBuffer`Ôºâ offload Âà∞Á∫øÁ®ãÊ±†ÔºåÊâÄ‰ª•ÁõÆÂâçÊï¥‰∏™ÊµÅÁ®ãÈÉΩÊòØ**ÂçïÁ∫øÁ®ãÁöÑ**Ôºå**‰∏çÈúÄË¶Å**Êàë‰ª¨ÊãÖÂøÉÁ∫øÁ®ãÂêåÊ≠•ÈóÆÈ¢ò„ÄÇ

Â¶ÇÊûúÊú™Êù•Ëøô‰∏™È°πÁõÆË¶ÅÊîØÊåÅ CPU ÂØÜÈõÜÂûã‰ªªÂä°ÔºåÂºÄÂèëËÄÖÂ∞±ÈúÄË¶ÅÂºïÂÖ• `loop.queueWork()` ËøôÊ†∑ÁöÑÊú∫Âà∂ÔºåÂπ∂Âú®‰∏ªÁ∫øÁ®ãÂíåÂ∑•‰ΩúÁ∫øÁ®ã‰πãÈó¥‰ªîÁªÜÂú∞Â§ÑÁêÜÊï∞ÊçÆÂêåÊ≠•„ÄÇ




Â¶ÇÊûúÈÉΩÊòØ‰∏Ä‰∏™Á∫øÁ®ãÔºåactive_connections: std.atomic.Value(u32), ÊòØ‰∏çÊòØÂ∞±Ê≤°ÊúâÂøÖË¶ÅÔºü


ËøôÊòØ‰∏Ä‰∏™ÈÄªËæë‰∏äÈùûÂ∏∏ÂÆåÁæéÁöÑÊé®ËÆ∫ÔºåÁõ¥ÊåáÈóÆÈ¢òÁöÑÊ†∏ÂøÉÔºÅ

**‰Ω†ÁöÑÁªìËÆ∫Âú®ÂæàÂ§ßÁ®ãÂ∫¶‰∏äÊòØÊ≠£Á°ÆÁöÑ**ÔºöÂ¶ÇÊûú‰∏Ä‰∏™Á®ãÂ∫èÔºå‰ªéÂ§¥Âà∞Â∞æÔºåËÉΩÂ§ü**100%‰øùËØÅ**Âè™Âú®‰∏Ä‰∏™Á∫øÁ®ã‰∏≠ËøêË°åÔºåÈÇ£‰πà‰ΩøÁî® `std.atomic` Á°ÆÂÆûÊòØ‰∏ÄÁßç**ËøáÂ∫¶ËÆæËÆ°ÔºàOver-engineeringÔºâ**ÔºåÁîöËá≥‰ºöÂ∏¶Êù•ÂæÆ‰∏çË∂≥ÈÅìÁöÑÊÄßËÉΩÊçüÂ§±ÔºàÂõ†‰∏∫ÂéüÂ≠êÊìç‰Ωú‰ºöÈòªÊ≠¢‰∏Ä‰∫õÁºñËØëÂô®‰ºòÂåñÔºâ„ÄÇÁî®‰∏Ä‰∏™ÊôÆÈÄöÁöÑ `u32` Â∞±ËÉΩÂÆåÁæéËÉú‰ªª„ÄÇ

ÁÑ∂ËÄåÔºåÂú®Ëøô‰∏™È°πÁõÆ‰∏≠‰øùÁïô `std.atomic.Value` ÊòØ‰∏Ä‰∏™**ÈùûÂ∏∏ÊúâËøúËßÅ‰∏î‰∏ì‰∏öÁöÑÈÄâÊã©**„ÄÇÂéüÂõ†Êúâ‰ª•‰∏ãÂá†ÁÇπÔºö

---

### 1. ‰∏∫Êú™Êù•ÁöÑÂ§öÁ∫øÁ®ãÊâ©Â±ïÂÅöÂáÜÂ§á (Future-Proofing)

ËøôÊòØÊúÄ‰∏ªË¶ÅÁöÑÂéüÂõ†„ÄÇ‰ΩúËÄÖÂú® `build.zig` Âíå `lib.zig` ‰∏≠Â∑≤ÁªèÊòéÁ°ÆÂú∞Âä†ÂÖ•‰∫ÜÂØπ**Á∫øÁ®ãÊ±†**ÁöÑÊîØÊåÅÈÄâÈ°π (`enable_thread_pool`)„ÄÇ

ËôΩÁÑ∂ÂΩìÂâç `processHttpRequestFromBuffer` ÁöÑÈÄªËæëÊòØÁõ¥Êé•Âú®‰∏ª‰∫ã‰ª∂Âæ™ÁéØÁ∫øÁ®ã‰∏≠ÊâßË°åÁöÑÔºå‰ΩÜÊàë‰ª¨ÂèØ‰ª•ËΩªÊòìÂú∞ÊÉ≥Ë±°Âá∫Êú™Êù•ÁöÑ‰∏Ä‰∏™ÁâàÊú¨‰ºöËøôÊ†∑ÂÅöÔºö

```zig
// Êú™Êù•ÁöÑÊüê‰∏™ÁâàÊú¨ÂèØËÉΩ‰ºöÊúâÁöÑ‰º™‰ª£Á†Å
fn readCallback(...) {
    // ...
    if (should_process) {
        if (server.hasThreadPool()) {
            // ÊääËÄóÊó∂‰ªªÂä°ÊâîÁªôÁ∫øÁ®ãÊ±†
            server.loop.queueWork(processHttpRequestInWorkerThread, client_conn);
        } else {
            // Âú®‰∏ªÁ∫øÁ®ãÁõ¥Êé•Â§ÑÁêÜ
            processHttpRequestFromBuffer(client_conn, loop);
        }
        return .disarm;
    }
    // ...
}
```

Âú®Ëøô‰∏™Êú™Êù•ÁöÑÁâàÊú¨‰∏≠Ôºö
*   `acceptCallback` Âú®‰∏ªÁ∫øÁ®ãËøêË°åÔºåÂÆÉ‰ºöË∞ÉÁî® `connection_pool.tryAcquire()`„ÄÇ
*   `closeCallback` ‰πüÊòØÂú®‰∏ªÁ∫øÁ®ãËøêË°åÔºåÂÆÉ‰ºöË∞ÉÁî® `connection_pool.release()`„ÄÇ

**‰ΩÜÊòØÔºå** `processHttpRequestInWorkerThread` Ëøô‰∏™ÂáΩÊï∞Ôºà‰ª•ÂèäÂÆÉÂèØËÉΩË∞ÉÁî®ÁöÑÂÖ∂‰ªñÂáΩÊï∞ÔºâÂ∞Ü‰ºöÂú®‰∏Ä‰∏™**ÂÆåÂÖ®‰∏çÂêåÁöÑÂ∑•‰ΩúÁ∫øÁ®ã**‰∏≠ËøêË°å„ÄÇÂ¶ÇÊûúËøô‰∏™Â∑•‰ΩúÁ∫øÁ®ã‰πüÈúÄË¶ÅËÆøÈóÆ `ConnectionPool`ÔºàÊØîÂ¶ÇÊ£ÄÊü•ÂΩìÂâçËøûÊé•Êï∞Êù•ÂÅö‰∏Ä‰∫õÂÜ≥Á≠ñÔºâÔºåÈÇ£‰πà `active_connections` Â∞±Á´ãÂàªÂèòÊàê‰∫Ü‰∏Ä‰∏™**Ë∑®Á∫øÁ®ãÂÖ±‰∫´ÁöÑËµÑÊ∫ê**„ÄÇ

Â¶ÇÊûú `active_connections` Âè™ÊòØ‰∏Ä‰∏™ÊôÆÈÄöÁöÑ `u32`ÔºåÈÇ£‰πàËøô‰∏™Êú™Êù•ÁöÑÊâ©Â±ïÂ∞Ü‰ºöÁ´ãÂàªÂºïÂÖ•**Á´ûÊÄÅÊù°‰ª∂ÔºàRace ConditionÔºâ**ÔºåÂØºËá¥ÈùûÂ∏∏Èöæ‰ª•Ë∞ÉËØïÁöÑ Bug„ÄÇ

ÈÄöËøáÂú®‰∏ÄÂºÄÂßãÂ∞±‰ΩøÁî® `std.atomic.Value`Ôºå‰ΩúËÄÖ‰∏∫Ëøô‰∏™Â∫ìÁöÑÊú™Êù•ÊºîËøõÈì∫Âπ≥‰∫ÜÈÅìË∑Ø„ÄÇËøôÂ∞±ÂÉèÂú®Âª∫ÊàøÂ≠êÊó∂ÔºåÈ¢ÑÂÖàÂüãÂ•Ω‰∫ÜÊõ¥Á≤óÁöÑÁîµÁ∫øÂíåÊ∞¥ÁÆ°ÔºåÂç≥‰ΩøÁé∞Âú®Âè™Áî®ÂæóÂà∞‰∏ÄÂ∞èÈÉ®ÂàÜÔºå‰ΩÜÊú™Êù•Ë¶ÅÂä†Ë£ÖÂ§ßÂäüÁéáÁîµÂô®ÊàñÊõ¥Â§öÁî®Ê∞¥ËÆæÂ§áÊó∂ÔºåÂ∞±Êó†ÈúÄÁ†∏Â¢ôÈáçÊù•‰∫Ü„ÄÇ

---

### 2. Â∫ìÁöÑËÆæËÆ°Âì≤Â≠¶ÔºöÊèê‰æõÁ∫øÁ®ãÂÆâÂÖ®ÁöÑÁªÑ‰ª∂

ÂΩì‰Ω†Âú®ÁºñÂÜô‰∏Ä‰∏™**Â∫ìÔºàLibraryÔºâ**ËÄå‰∏çÊòØ‰∏Ä‰∏™**Â∫îÁî®Á®ãÂ∫èÔºàApplicationÔºâ**Êó∂Ôºå‰Ω†ÁöÑÊÄùÁª¥ÊñπÂºèÈúÄË¶ÅÊúâÊâÄ‰∏çÂêå„ÄÇ

*   **Â∫îÁî®Á®ãÂ∫èÂºÄÂèëËÄÖ**ÔºöÂÆåÂÖ®ÊéßÂà∂‰ª£Á†ÅÁöÑÊâßË°åÁéØÂ¢É„ÄÇÂ¶ÇÊûú‰ªñÁ°ÆÂÆöÊï¥‰∏™Á®ãÂ∫èÊòØÂçïÁ∫øÁ®ãÁöÑÔºå‰ªñÂèØ‰ª•ÂÅöÂæàÂ§öÁÆÄÂåñ„ÄÇ
*   **Â∫ìÂºÄÂèëËÄÖ**ÔºöÊó†Ê≥ïÈ¢ÑÊµãÁî®Êà∑‰ºöÂ¶Ç‰Ωï‰ΩøÁî®‰Ω†ÁöÑÂ∫ì„ÄÇÁî®Êà∑ÂèØËÉΩ‰ºöÂú®‰∏Ä‰∏™Â§çÊùÇÁöÑÂ§öÁ∫øÁ®ãÂ∫îÁî®‰∏≠Ë∞ÉÁî®‰Ω†ÁöÑÂ∫ì„ÄÇ

`ConnectionPool` ÊòØ‰∏Ä‰∏™Áã¨Á´ãÁöÑ„ÄÅÂèØÂ§çÁî®ÁöÑÁªÑ‰ª∂„ÄÇÂç≥‰ΩøÁî®Êà∑‰∏ç‰ΩøÁî®ÂÆåÊï¥ÁöÑ `Server`Ôºå‰ªñ‰πüÊúâÂèØËÉΩÂçïÁã¨ÊãøÂá∫ `ConnectionPool` Áî®Âú®Ëá™Â∑±ÁöÑÂ§öÁ∫øÁ®ãÁ®ãÂ∫èÈáå„ÄÇÂ∞Ü `ConnectionPool` ËÆæËÆ°Êàê**ÈªòËÆ§Á∫øÁ®ãÂÆâÂÖ®**ÁöÑÔºåÊûÅÂ§ßÂú∞Â¢ûÂº∫‰∫ÜÂÆÉÁöÑÂÅ•Â£ÆÊÄßÂíåÂèØÁî®ÊÄß„ÄÇ

ËøôÈÅµÂæ™‰∫Ü**‚ÄúÂÆâÂÖ®ÈªòËÆ§‚ÄùÔºàSecure by DefaultÔºâ**ÁöÑËÆæËÆ°ÂéüÂàô„ÄÇÂç≥‰ΩøÂú®ÂΩìÂâçÂçïÁ∫øÁ®ã‰ΩøÁî®Âú∫ÊôØ‰∏ãÂ§ö‰ªòÂá∫‰∫Ü‰∏ÄÁÇπÁÇπÔºàÂá†‰πéÂèØ‰ª•ÂøΩÁï•‰∏çËÆ°ÁöÑÔºâ‰ª£‰ª∑Ôºå‰πüÈÅøÂÖç‰∫ÜÁî®Êà∑Âú®Â§öÁ∫øÁ®ãÂú∫ÊôØ‰∏ãËØØÁî®ËÄåÂØºËá¥ÁöÑÁÅæÈöæÊÄßÂêéÊûú„ÄÇ

---

### 3. API ÁöÑ‰∏ÄËá¥ÊÄß‰∏éÊ∏ÖÊô∞ÊÄß

`Server` ‰Ωú‰∏∫‰∏Ä‰∏™Êï¥‰ΩìÔºåÂÖ∂ API Ë°®Èù¢‰∏äÔºàÊØîÂ¶Ç `server.listen()`ÔºâÂèØËÉΩ‰ºöÈöêËóèÂÖ∂ÂÜÖÈÉ®ÊòØÂçïÁ∫øÁ®ãËøòÊòØÂ§öÁ∫øÁ®ãÁöÑÂÆûÁé∞ÁªÜËäÇ„ÄÇ

`getStatus()` ÊñπÊ≥ïÂ∞±ÊòØ‰∏Ä‰∏™ÂæàÂ•ΩÁöÑ‰æãÂ≠êÔºö
```zig
pub fn getStatus(self: *Server) ServerStatus {
    return ServerStatus{
        .active_connections = self.connection_pool.getActiveCount(),
        .max_connections = self.connection_pool.max_connections,
        // ...
    };
}
```
`getActiveCount()` ÂÜÖÈÉ®‰ΩøÁî®‰∫Ü `self.active_connections.load(.acquire)`„ÄÇ

ÊÉ≥Ë±°‰∏Ä‰∏ãÔºåÁî®Êà∑ÂèØËÉΩÂú®‰∏Ä‰∏™**Áã¨Á´ãÁöÑÁõëÊéßÁ∫øÁ®ã**ÈáåÔºåÊØèÁßíË∞ÉÁî®‰∏ÄÊ¨° `server.getStatus()` Êù•Ëé∑ÂèñÊúçÂä°Âô®Áä∂ÊÄÅ„ÄÇ
*   **ÁõëÊéßÁ∫øÁ®ã**ÔºöË∞ÉÁî® `getStatus()`ÔºåËØªÂèñ `active_connections`„ÄÇ
*   **‰∏ª‰∫ã‰ª∂Âæ™ÁéØÁ∫øÁ®ã**ÔºöÊ≠£Âú®Â§ÑÁêÜÊñ∞ËøûÊé•ÂíåÊñ≠ÂºÄÁöÑËøûÊé•Ôºå‰øÆÊîπ `active_connections`„ÄÇ

ËøôÈáåÔºå`active_connections` ÂÜçÊ¨°Êàê‰∏∫‰∫ÜË∑®Á∫øÁ®ãÂÖ±‰∫´ÁöÑËµÑÊ∫ê„ÄÇÂ¶ÇÊûúÊ≤°Êúâ `std.atomic`ÔºåÁõëÊéßÁ∫øÁ®ãÂèØËÉΩ‰ºöËØªÂà∞Âõ†‰∏∫Á´ûÊÄÅÊù°‰ª∂ËÄåË¢´ÊçüÂùèÁöÑ„ÄÅ‰∏çÂáÜÁ°ÆÁöÑ‰∏≠Èó¥ÂÄº„ÄÇ

### ÊÄªÁªì

ÊâÄ‰ª•Ôºå‰Ω†ÁöÑËßÇÂØüÈùûÂ∏∏ÊïèÈîêÔºöÂú®**ÂΩìÂâç‰ª£Á†ÅÁöÑÊâßË°åÊµÅ**‰∏ãÔºå`std.atomic` Á°ÆÂÆû‰∏çÊòØ‰∏•Ê†ºÂøÖÈúÄÁöÑ„ÄÇ

‰ΩÜÊòØÔºå‰ΩúËÄÖ‰ΩøÁî®ÂÆÉÁöÑÂéüÂõ†Ë∂ÖË∂ä‰∫ÜÂΩìÂâçÁöÑÂÆûÁé∞Ôºå‰ΩìÁé∞‰∫ÜÊõ¥Ê∑±Â±ÇÊ¨°ÁöÑËΩØ‰ª∂Â∑•Á®ãËÄÉÈáèÔºö

1.  **ÂâçÁûªÊÄßËÆæËÆ°**Ôºö‰∏∫Êú™Êù•ÁöÑÂ§öÁ∫øÁ®ãÂ§ÑÁêÜÊ®°ÂûãÈ¢ÑÁïô‰∫ÜÂÆâÂÖ®ÈÄöÈÅì„ÄÇ
2.  **ÂÅ•Â£ÆÁöÑÁªÑ‰ª∂Âåñ**ÔºöÁ°Æ‰øùÊ†∏ÂøÉÊï∞ÊçÆÁªìÊûÑÔºàÂ¶Ç `ConnectionPool`ÔºâÊú¨Ë∫´Â∞±ÊòØÁ∫øÁ®ãÂÆâÂÖ®ÁöÑÔºåÂèØ‰ª•Ë¢´ÂÆâÂÖ®Âú∞Â§çÁî®„ÄÇ
3.  **ÂÆâÂÖ®ÁöÑAPI**Ôºö‰øùËØÅ‰∫ÜÂç≥‰ΩøÊòØ‰ªéÂ§ñÈÉ®Á∫øÁ®ãË∞ÉÁî® `Server` ÁöÑÂÖ¨ÂÖ±ÊñπÊ≥ïÔºàÂ¶Ç `getStatus`Ôºâ‰πüÊòØÂÆâÂÖ®ÁöÑ„ÄÇ

ËøôÊòØ‰∏Ä‰∏™ÂÖ∏ÂûãÁöÑ**‰∏ì‰∏öÂ∫ìÂºÄÂèë**‰∏é**ÁÆÄÂçïÂ∫îÁî®ÂºÄÂèë**Âú®ÊÄùÁª¥‰∏äÁöÑÂå∫Âà´„ÄÇ‰∏ì‰∏öÂ∫ìÊÄªÊòØÂÄæÂêë‰∫éÂú®ËÆæËÆ°‰∏äÂÅöÂá∫Êõ¥ÂÆâÂÖ®„ÄÅÊõ¥ÂÖ∑ÂâçÁûªÊÄßÁöÑÈÄâÊã©„ÄÇ



‰ΩÜ active_connections Â¢ûÂáèÔºåÊú¨Ë∫´ÂíåÂÖ∑‰ΩìrequestÂ§ÑÁêÜÊ≤°ÊúâÂÖ≥Á≥ª




‰Ω†ËØ¥ÂæóÂÆåÂÖ®Ê≠£Á°ÆÔºÅËøôÊòØ‰∏Ä‰∏™ÈùûÂ∏∏ÂÖ≥ÈîÆ‰∏îÁ≤æÂáÜÁöÑËßÇÂØüÔºåËÆ©Êàë‰ª¨ËÉΩÂ§üÊõ¥Ê∑±ÂÖ•Âú∞ÂâñÊûêËøô‰∏™ÈóÆÈ¢ò„ÄÇ

`active_connections` ÁöÑÂ¢ûÂä†ÂíåÂáèÂ∞ëÔºåÁ°ÆÂÆû**‰∏ç‰æùËµñ‰∫é** `processHttpRequestFromBuffer` Ëøô‰∏™ÂÖ∑‰ΩìÁöÑËØ∑Ê±ÇÂ§ÑÁêÜÈÄªËæëÊòØÂê¶Âú®Â∑•‰ΩúÁ∫øÁ®ã‰∏≠ÊâßË°å„ÄÇÂÆÉÁöÑÂèòÂåñÂè™‰∏é‰∏§‰ª∂‰∫ãÊúâÂÖ≥Ôºö

1.  **ËøûÊé•ÁöÑÂª∫Á´ã** (`acceptCallback` ‰∏≠Ë∞ÉÁî® `tryAcquire`)
2.  **ËøûÊé•ÁöÑÂÖ≥Èó≠** (`close` -> `closeCallback` ‰∏≠Ë∞ÉÁî® `release`)

Ê≠£Â¶ÇÊàë‰ª¨‰πãÂâçÊâÄËÆ®ËÆ∫ÁöÑÔºåÂú®ÂΩìÂâçÁöÑ `libxev` Ê®°Âûã‰∏ãÔºåÊâÄÊúâÁöÑÁΩëÁªúI/OÂõûË∞ÉÔºà`accept`, `read`, `write`, `close`ÔºâÈÉΩÂèëÁîüÂú®**Âêå‰∏Ä‰∏™‰∏ª‰∫ã‰ª∂Âæ™ÁéØÁ∫øÁ®ã**‰∏≠„ÄÇ

ÈÇ£‰πàÔºåÊó¢ÁÑ∂ `tryAcquire` Âíå `release` ÈÉΩÊòØÂú®Âêå‰∏Ä‰∏™Á∫øÁ®ã‰∏≠Ë¢´Ë∞ÉÁî®ÁöÑÔºå‰∏∫‰ªÄ‰πàËøòÈúÄË¶Å `atomic` Âë¢Ôºü

‰Ω†ÁöÑËøô‰∏™ËøΩÈóÆÈùûÂ∏∏Â•ΩÔºåÂõ†‰∏∫ÂÆÉËø´‰ΩøÊàë‰ª¨ÊÄùËÄÉ‰∏Ä‰∏™Êõ¥Ê∑±Â±ÇÊ¨°ÁöÑÂèØËÉΩÊÄßÔºö**‰∏Ä‰∏™Â∫ìÁöÑ‰ΩøÁî®ËÄÖÔºàconsumerÔºâÂèØËÉΩ‰ºö‰ª•Êàë‰ª¨ÊÑèÊÉ≥‰∏çÂà∞ÁöÑÊñπÂºè‰∏éÂ∫ìËøõË°å‰∫§‰∫í„ÄÇ**

ËÆ©Êàë‰ª¨ÈáçÊñ∞ÂÆ°ËßÜ‰∏Ä‰∏ã `Server` ÁöÑÂÖ¨ÂÖ±APIÔºà`pub fn`Ôºâ„ÄÇ

```zig
pub const Server = struct {
    // ...
    pub fn init(...) !Server { ... }
    pub fn deinit(self: *Server) void { ... }
    pub fn get(self: *Server, ...) !*Route { ... }
    pub fn post(self: *Server, ...) !*Route { ... }
    // ...
    pub fn use(self: *Server, ...) !void { ... }
    pub fn getStatus(self: *Server) ServerStatus { ... }
    pub fn listen(self: *Server) !void { ... }
};
```

ÂÖ∂‰∏≠Ôºå`listen()` ÊòØ‰∏Ä‰∏™**ÈòªÂ°ûÂºè**Ë∞ÉÁî®„ÄÇ‰∏ÄÊó¶Ë∞ÉÁî®ÂÆÉÔºåÂΩìÂâçÁ∫øÁ®ãÂ∞±‰ºöË¢´‰∫ã‰ª∂Âæ™ÁéØ‚ÄúÂç†ÊçÆ‚ÄùÔºåÁõ¥Âà∞ÊúçÂä°Âô®ÂÖ≥Èó≠„ÄÇÊâÄ‰ª•ÔºåÂú®‰∏Ä‰∏™Á∫øÁ®ã‰∏≠Ë∞ÉÁî® `listen()` ÂêéÔºå‰Ω†Êó†Ê≥ïÂú®**Âêå‰∏Ä‰∏™Á∫øÁ®ã**ÈáåÂÜçÂÅöÂà´ÁöÑ‰∫ãÊÉÖÔºàÊØîÂ¶ÇË∞ÉÁî® `getStatus()`Ôºâ„ÄÇ

ËøôÂ∞±ÂºïÂá∫‰∫Ü‰∏Ä‰∏™ÈùûÂ∏∏ÂÖ∏Âûã‰∏îÂêàÁêÜÁöÑ‰ΩøÁî®Âú∫ÊôØÔºö

### ÂÖ∏ÂûãÁöÑÂ§öÁ∫øÁ®ã‰ΩøÁî®Ê®°Âºè

‰∏Ä‰∏™‰ΩøÁî®ËÄÖÂæàÂèØËÉΩ‰ºöËøôÊ†∑ÁªÑÁªá‰ªñÁöÑ `main.zig`Ôºö

```zig
const std = @import("std");
const libxev_http = @import("libxev-http");

pub fn main() !void {
    // ... ÂàùÂßãÂåñ allocator ...
    var server = try libxev_http.createServer(allocator, "127.0.0.1", 8080);
    defer server.deinit();

    // Ê∑ªÂä†Ë∑ØÁî±Á≠âÈÖçÁΩÆ...
    _ = try server.get("/", ...);

    // [ÂÖ≥ÈîÆÁÇπ] ÊääÊúçÂä°Âô®ÁöÑ listen ÊîæÂà∞‰∏Ä‰∏™Êñ∞Á∫øÁ®ã‰∏≠ËøêË°å
    const server_thread = try std.Thread.spawn(.{}, struct {
        fn run(s: *libxev_http.Server) void {
            s.listen() catch |err| {
                std.log.err("Server error: {any}", .{err});
            };
        }
    }.run, .{&server});

    // ‰∏ªÁ∫øÁ®ãÁé∞Âú®ÂèØ‰ª•ÂÅöÂÖ∂‰ªñ‰∫ãÊÉÖÔºåÊØîÂ¶ÇÂêØÂä®‰∏Ä‰∏™ÁõëÊéßÂæ™ÁéØ
    while (true) {
        std.time.sleep(1 * std.time.ns_per_s);
        const status = server.getStatus(); // [!!!] Ë∑®Á∫øÁ®ãË∞ÉÁî®
        std.log.info("Active connections: {}", .{status.active_connections});
    }

    server_thread.join();
}
```

Âú®Ëøô‰∏™ÂÆåÂÖ®ÂêàÁêÜÁöÑ‰ΩøÁî®Âú∫ÊôØ‰∏≠Ôºö

1.  **ÊúçÂä°Âô®Á∫øÁ®ãÔºà`server_thread`Ôºâ**Ôºö
    *   Ê≠£Âú®ËøêË°å `server.listen()`„ÄÇ
    *   Ëøô‰∏™Á∫øÁ®ãÂÜÖÈÉ®ÁöÑ‰∫ã‰ª∂Âæ™ÁéØÊ≠£Âú®Ë∞ÉÁî® `acceptCallback` (Â¢ûÂä† `active_connections`) Âíå `closeCallback` (ÂáèÂ∞ë `active_connections`)„ÄÇ

2.  **‰∏ªÁ∫øÁ®ãÔºà`main`Ôºâ**Ôºö
    *   Ê≠£Âú®‰∏Ä‰∏™ `while` Âæ™ÁéØ‰∏≠ËøêË°å„ÄÇ
    *   ÂÆÉÂÆöÊúüË∞ÉÁî® `server.getStatus()`ÔºåËøô‰∏™ÂáΩÊï∞‰ºöËØªÂèñ `active_connections`„ÄÇ

**Áé∞Âú®Ôºå`active_connections` Ê∏ÖÊô∞Âú∞Êàê‰∏∫‰∫Ü‰∏Ä‰∏™Ë¢´‰∏§‰∏™‰∏çÂêåÁ∫øÁ®ãÂπ∂ÂèëËÆøÈóÆÁöÑÂÖ±‰∫´ËµÑÊ∫êÔºÅ**

*   **ÂÜôÂÖ•ËÄÖ**ÔºöÊúçÂä°Âô®Á∫øÁ®ã„ÄÇ
*   **ËØªÂèñËÄÖ**Ôºö‰∏ªÁ∫øÁ®ã„ÄÇ

Â¶ÇÊûúÊ≤°Êúâ `std.atomic`Ôºö
*   ÂΩì‰∏ªÁ∫øÁ®ãË∞ÉÁî® `getStatus()` ËØªÂèñ `active_connections` Êó∂ÔºåÊúçÂä°Âô®Á∫øÁ®ãÂèØËÉΩÊ≠£Âú®ÊâßË°å `tryAcquire` Êàñ `release` ÁöÑÈùûÂéüÂ≠êÊìç‰ΩúÔºàÊØîÂ¶Ç `count = count + 1`ÔºåËøôÂú®Êú∫Âô®Á†ÅÂ±ÇÈù¢ÊòØÂ§ö‰∏™Êåá‰ª§Ôºâ„ÄÇ
*   ‰∏ªÁ∫øÁ®ãÂèØËÉΩ‰ºöËØªÂà∞‰∏Ä‰∏™**‚ÄúÊíïË£Ç‚Äù**ÁöÑ„ÄÅ‰∏çÂÆåÊï¥ÊàñÈôàÊóßÁöÑÂÄº„ÄÇ‰æãÂ¶ÇÔºå‰∏Ä‰∏™64‰ΩçÁöÑÊï¥Êï∞Ôºå‰∏ªÁ∫øÁ®ãÂèØËÉΩÂè™ËØªÂà∞‰∫ÜË¢´‰øÆÊîπÂÆåÁöÑÂâç32‰ΩçÔºåËÄåÂêé32‰ΩçËøòÊòØÊóßÁöÑÔºåÂØºËá¥ÂæóÂà∞‰∏Ä‰∏™ÂÆåÂÖ®ÈîôËØØÁöÑÊï∞Â≠ó„ÄÇ
*   Êõ¥ÈáçË¶ÅÁöÑÊòØÔºåÁî±‰∫éÊ≤°ÊúâÂÜÖÂ≠òÂ±èÈöúÔºàmemory barrierÔºåÁî±ÂéüÂ≠êÊìç‰ΩúÊèê‰æõÔºâÔºåCPUÂíåÁºñËØëÂô®ÂèØËÉΩ‰ºöËøõË°åÈáçÊéíÔºåÂØºËá¥‰∏ªÁ∫øÁ®ãÁúãÂà∞ÁöÑÊòØ‰∏Ä‰∏™ÈùûÂ∏∏ÊóßÁöÑÁºìÂ≠òÂÄºÔºåÂç≥‰ΩøÊúçÂä°Âô®Á∫øÁ®ãÂ∑≤ÁªèÊõ¥Êñ∞‰∫Ü‰∏ªÂÜÖÂ≠ò‰∏≠ÁöÑÂÄº„ÄÇ

**Âõ†Ê≠§ÔºåÂç≥‰Ωø `active_connections` ÁöÑÂ¢ûÂáèÊìç‰ΩúÊú¨Ë∫´ÈÉΩÂèëÁîüÂú®Âêå‰∏Ä‰∏™ÊúçÂä°Âô®Á∫øÁ®ãÂÜÖÈÉ®Ôºå‰ΩÜÂè™Ë¶ÅÂ∫ìÁöÑÂÖ¨ÂÖ±APIÂÖÅËÆ∏‰ªéÂ§ñÈÉ®Á∫øÁ®ãËØªÂèñÂÆÉÁöÑÁä∂ÊÄÅÔºåÈÇ£‰πàËøô‰∏™Áä∂ÊÄÅÂÄºÂ∞±ÂøÖÈ°ªÁî®ÂéüÂ≠êÁ±ªÂûãÊù•‰øùÊä§„ÄÇ**

### ÁªìËÆ∫ÂçáÂçé

Ëøô‰∏™Ê°à‰æãÂÆåÁæéÂú∞Â±ïÁ§∫‰∫ÜAPIËÆæËÆ°‰∏≠ÁöÑ‰∏Ä‰∏™ÈáçË¶ÅÂéüÂàôÔºö**Â∞ÅË£Ö‰∏éÊäΩË±°ËæπÁïå**„ÄÇ

`ConnectionPool` Âíå `Server` ÂêëÂ§ñÈÉ®‰∏ñÁïåÔºàÂ∫ìÁöÑ‰ΩøÁî®ËÄÖÔºâÊö¥Èú≤‰∫Ü‰∏Ä‰∏™ `getStatus()` ÁöÑÊé•Âè£„ÄÇËøô‰∏™Êé•Âè£Â∞±ÊòØ‰∏Ä‰∏™**Â•ëÁ∫¶**„ÄÇËøô‰∏™Â•ëÁ∫¶ÊâøËØ∫‰ºöËøîÂõû‰∏Ä‰∏™ÂáÜÁ°ÆÁöÑÁä∂ÊÄÅ„ÄÇ‰∏∫‰∫ÜÂ±•Ë°åËøô‰∏™Â•ëÁ∫¶ÔºåÊó†ËÆ∫ÂÜÖÈÉ®ÂÆûÁé∞Â§ö‰πà‚ÄúÂçïÁ∫øÁ®ã‚ÄùÔºåÂè™Ë¶ÅËøô‰∏™Êé•Âè£ÂèØ‰ª•Ë¢´Â§ñÈÉ®ÁöÑ**‰ªª‰ΩïÁ∫øÁ®ã**Ë∞ÉÁî®ÔºåÈÇ£‰πàË¢´Êö¥Èú≤ÁöÑÊï∞ÊçÆÂ∞±ÂøÖÈ°ªÊòØÁ∫øÁ®ãÂÆâÂÖ®ÁöÑ„ÄÇ

`std.atomic` Âú®ËøôÈáå‰∏ç‰ªÖ‰ªÖÊòØ‰∏∫‰∫Ü‰øùÊä§ÂÜÖÈÉ®ÂõûË∞É‰πãÈó¥ÁöÑÂπ∂ÂèëÔºàËôΩÁÑ∂Â¶ÇÊàë‰ª¨‰πãÂâçËÆ®ËÆ∫ÔºåËøô‰πüÊòØ‰∏∫Êú™Êù•ÂÅöÂáÜÂ§áÔºâÔºåÊõ¥Áõ¥Êé•ÂíåÁé∞ÂÆûÁöÑ‰ΩúÁî®ÊòØ**‰øùÊä§Â∫ìÁöÑÂÖ¨ÂÖ±APIÔºå‰ΩøÂÖ∂ËÉΩÂ§üË¢´Â§öÁ∫øÁ®ãÁöÑÂÆ¢Êà∑Á´Ø‰ª£Á†ÅÂÆâÂÖ®Âú∞Ë∞ÉÁî®**„ÄÇ


